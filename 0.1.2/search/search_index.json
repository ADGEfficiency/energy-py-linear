{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"energy-py-linear","text":"<p>A Python library for optimizing energy assets with mixed-integer linear programming:</p> <ul> <li>electric batteries,</li> <li>combined heat &amp; power (CHP) generators,</li> <li>electric vehicle smart charging.</li> </ul> <p>Assets can be optimized to either maximize profit or minimize carbon emissions.  </p> <p>Energy balances are performed on electricity, high &amp; low temperature heat.</p>"},{"location":"#setup","title":"Setup","text":"<p>Requires Python 3.10+:</p> <pre><code>$ pip install energypylinear\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#asset-api","title":"Asset API","text":"<p>The asset API allows optimizing a single asset at once.</p> <p>We can optimize an electric battery operating in wholesale price arbitrage using <code>epl.Battery</code>:</p> <pre><code>import energypylinear as epl\n#  2.0 MW, 4.0 MWh battery\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4, efficiency=0.9)\nresults = asset.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3\n)\n</code></pre> <p>You can find documentation of how to optimize other assets in how-to/optimize-assets, and Python examples in energy-py-linear/examples/examples.</p>"},{"location":"#site-api","title":"Site API","text":"<p>The site API allows optimizing multiple assets at once:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(assets=[\nepl.Battery(power_mw=2.0, capacity_mwh=4.0),\nepl.Generator(\nelectric_power_max_mw=100,\nelectric_power_min_mw=30,\nelectric_efficiency_pct=0.4\n),\nepl.evs.EVs(charger_mws=[100, 100])\n])\nresults = site.optimize(\nelectricity_prices=[100, 50, 200, -100, 0],\nhigh_temperature_load_mwh=[105, 110, 120, 110, 105],\nlow_temperature_load_mwh=[105, 110, 120, 110, 105],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3,\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 0],\n[0, 0, 0, 1, 1],\n[0, 1, 0, 0, 0],\n],\ncharge_event_mwh=[50, 100, 30, 40]\n)\n</code></pre> <p>The site API will optimize the assets together, and return the results for each asset.</p>"},{"location":"getting-started/","title":"hi","text":""},{"location":"validation/","title":"Validation","text":"<p>A natural response when you get access to something someone else build is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of underlying energy models.</p>"},{"location":"validation/#battery-validation","title":"Battery Validation","text":""},{"location":"validation/#price-dispatch-behaviour","title":"Price Dispatch Behaviour","text":"<p>Let's optimize a battery using a sequence of five prices.</p> <p>We expect that the battery will charge when prices are low, and will discharge when prices are high.</p> <p>In <code>energypylinear</code>, a positive site electricity balance is importing, and a negative site electricity balance is exporting.</p> <pre><code>import energypylinear as epl\nasset = epl.Battery()\nresults = asset.optimize(electricity_prices=[10, -50, 200, -50, 200], verbose=False)\nprint(results.simulation[[\"electricity_prices\", \"site-electricity_balance_mwh\"]])\n</code></pre> <pre><code>   electricity_prices  site-electricity_balance_mwh\n0                  10                      0.444444\n1                 -50                      2.000000\n2                 200                     -2.000000\n3                 -50                      2.000000\n4                 200                     -2.000000\n</code></pre> <p>As expected, the battery charges (with a site that is positive) when prices are low and discharges (with a negative site electricity balance) when prices are high.</p> <p>Now let's change the prices and see how the dispatch changes:</p> <pre><code>import energypylinear as epl\nasset = epl.Battery()\nresults = asset.optimize(electricity_prices=[200, -50, -50, 200, 200], verbose=False)\nprint(results.simulation[[\"electricity_prices\", \"site-electricity_balance_mwh\"]])\n</code></pre> <pre><code>   electricity_prices  site-electricity_balance_mwh\n0                 200                           0.0\n1                 -50                           2.0\n2                 -50                           2.0\n3                 200                          -2.0\n4                 200                          -1.6\n</code></pre> <p>As expected, the battery continues to charge during low electricity price intervals, and discharge when electricity prices are high.</p>"},{"location":"validation/#energy-balance","title":"Energy Balance","text":"<p>Let's return to our original set of prices and check the energy balance of the battery:</p> <pre><code>import energypylinear as epl\nasset = epl.Battery()\nresults = asset.optimize(electricity_prices=[10, -50, 200, -50, 200], verbose=False)\nbalance = epl.results.check_electricity_balance(results.simulation, verbose=False)\nprint(balance)\n</code></pre> <pre><code>     import  generation  export  load    charge  discharge  balance      loss  spills\n0  0.444444         0.0     0.0   0.0  0.444444        0.0     True  0.044444     0.0\n1  2.000000         0.0     0.0   0.0  2.000000        0.0     True  0.200000     0.0\n2  0.000000         0.0     2.0   0.0  0.000000        2.0     True  0.000000     0.0\n3  2.000000         0.0     0.0   0.0  2.000000        0.0     True  0.200000     0.0\n4  0.000000         0.0     2.0   0.0  0.000000        2.0     True  0.000000     0.0\n</code></pre> <p>In the first interval, we charge the battery with <code>0.444444 MWh</code> - <code>0.4 MWh</code> goes into increasing the battery state of charge from <code>0.0 MWh</code> to <code>0.4 MWh</code>, with the balance <code>0.044444 MWh</code> going to battery losses.</p>"},{"location":"validation/#battery-efficiency","title":"Battery Efficiency","text":"<p>We can validate the performance of the battery efficiency by checking the losses across different battery efficiencies:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport energypylinear as epl\nout = []\nnp.random.seed(42)\nprices = (np.random.uniform(-100, 100, 12) + 100).tolist()\nfor efficiency_pct in [1.0, 0.9, 0.8]:\nasset = epl.battery.Battery(\npower_mw=4,\ncapacity_mwh=10,\nefficiency=efficiency_pct\n)\nresults = asset.optimize(\nelectricity_prices=prices,\nobjective=\"price\",\nverbose=False\n)\nout.append(\n{\n\"eff_pct\": efficiency_pct,\n\"charge_mwh\": results.simulation[\"battery-charge_mwh\"].sum(),\n\"discharge_mwh\": results.simulation[\"battery-discharge_mwh\"].sum(),\n\"loss_mwh\": results.simulation[\"battery-losses_mwh\"].sum(),\n\"prices_$_mwh\": results.simulation[\"electricity_prices\"].mean(),\n\"import_mwh\": results.simulation[\"site-import_power_mwh\"].sum(),\n\"objective\": (results.simulation[\"site-import_power_mwh\"] - results.simulation[\"site-export_power_mwh\"] * results.simulation[\"electricity_prices\"]).sum(),\n}\n)\nprint(pd.DataFrame(out))\n</code></pre> <pre><code>   eff_pct  charge_mwh  discharge_mwh  loss_mwh  prices_$_mwh  import_mwh    objective\n0      1.0   18.000000           18.0  0.000000    103.197695   18.000000 -3018.344310\n1      0.9   19.111111           17.2  1.911111    103.197695   19.111111 -2893.086854\n2      0.8   20.000000           16.0  4.000000    103.197695   20.000000 -2719.962419\n</code></pre> <p>From the above we observe the following as efficiency decreases:</p> <ul> <li>an increase in battery losses,</li> <li>a reduction in the amount charged and discharged,</li> <li>a increase in the objective function, which represents an increase in cost or decrease in value of the battery arbitrage.</li> </ul>"},{"location":"validation/#state-of-charge-power-ratings","title":"State of Charge &amp; Power Ratings","text":"<p>We can demonstrate the state of charge and battery power settings by first optimizing a battery and showing it's plot:</p> <pre><code>import numpy as np\nimport energypylinear as epl\nnp.random.seed(42)\nelectricity_prices = np.random.normal(100, 10, 10).tolist()\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4)\nresults = asset.optimize(electricity_prices=electricity_prices)\nasset.plot(results, path=\"./docs/docs/static/battery.png\")\n</code></pre> <p></p> <p>Takeaways:</p> <ul> <li>the battery state of charge is constrained between 0 and 4 MWh,</li> <li>the battery power rating is constrained between -2 and 2 MW,</li> <li>battery SOC starts empty and ends empty.</li> </ul> <pre><code>import numpy as np\nimport energypylinear as epl\nnp.random.seed(42)\nelectricity_prices = np.random.normal(100, 10, 10).tolist()\nasset = epl.battery.Battery(\npower_mw=4,\ncapacity_mwh=8,\n)\nresults = asset.optimize(\nelectricity_prices=electricity_prices,\ninitial_charge_mwh=1.0,\nfinal_charge_mwh=3.0\n)\nasset.plot(results, path=\"./docs/docs/static/battery-fast.png\")\n</code></pre> <p></p> <p>Takeaways:</p> <ul> <li>battery SOC starts at 1 MWh and ends at 3 MWh.</li> </ul>"},{"location":"how-to/dispatch-assets/","title":"Dispatching A Single Asset with the Asset API","text":"<p>The asset API allows optimizing a single asset at once.  Below we show how to use each asset in isolation with <code>asset.optimize</code>.</p>"},{"location":"how-to/dispatch-assets/#battery","title":"Battery","text":"<p>Dispatch an electric battery operating in wholesale price arbitrage using <code>epl.Battery</code>:</p> <pre><code>import energypylinear as epl\n#  2.0 MW, 4.0 MWh battery\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4, efficiency=0.9)\nresults = asset.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3\n)\nassert all(\nresults.simulation.columns == [\n'site-import_power_mwh',\n'site-export_power_mwh',\n'spill-electric_generation_mwh',\n'spill-electric_load_mwh',\n'spill-high_temperature_generation_mwh',\n'spill-low_temperature_generation_mwh',\n'spill-high_temperature_load_mwh',\n'spill-low_temperature_load_mwh',\n'spill-gas_consumption_mwh',\n'spill-charge_mwh',\n'spill-discharge_mwh',\n'battery-charge_mwh',\n'battery-charge_binary',\n'battery-discharge_mwh',\n'battery-discharge_binary',\n'battery-losses_mwh',\n'battery-initial_charge_mwh',\n'battery-final_charge_mwh',\n'electricity_prices',\n'electricity_carbon_intensities',\n'total-electric_generation_mwh',\n'total-electric_load_mwh',\n'total-high_temperature_generation_mwh',\n'total-low_temperature_generation_mwh',\n'total-high_temperature_load_mwh',\n'total-low_temperature_load_mwh',\n'total-gas_consumption_mwh',\n'total-charge_mwh',\n'total-discharge_mwh',\n'total-spills_mwh',\n'total-losses_mwh',\n'site-electricity_balance_mwh',\n'load-high_temperature_load_mwh',\n'load-low_temperature_load_mwh'\n]\n)\n</code></pre> <p>The battery will charge with electricity at low prices, and discharge at high prices.  An efficiency penalty is applied to the battery charge energy (energy is lost during charging).</p>"},{"location":"how-to/dispatch-assets/#generator","title":"Generator","text":"<p>Dispatch a CHP (combined heat &amp; power) generator to generate electricity, high &amp; low temperature heat from natural gas.</p> <p>The <code>epl.Generator</code> model can be configured with electric, high and low temperature thermal efficiencies. </p> <p>This allows modelling both gas engines and gas turbines.</p> <p>When optimizing, we can use interval data for the high and low temperature loads.  These thermal loads will be met by gas boilers if the CHP chooses not to generate, or cannot meet thermal demands.  High temperature heat can be let-down into low temperature heat.</p> <p>The <code>epl.Generator</code> is allowed to dump both high temperature and low temperature heat.</p> <p>The high and low temperature heat demands are supplied alongside the electricity prices when optimizing:</p> <pre><code>import energypylinear as epl\n#  100 MWe gas turbine\nasset = epl.chp.Generator(\nelectric_power_max_mw=100,\nelectric_power_min_mw=50,\nelectric_efficiency_pct=0.3,\nhigh_temperature_efficiency_pct=0.5,\n)\n#  100 MWe gas engine\nasset = epl.chp.Generator(\nelectric_power_max_mw=100,\nelectric_power_min_mw=10,\nelectric_efficiency_pct=0.4,\nhigh_temperature_efficiency_pct=0.2,\nlow_temperature_efficiency_pct=0.2,\n)\nresults = asset.optimize(\nelectricity_prices=[100, 50, 200, -100, 0, 200, 100, -100],\nhigh_temperature_load_mwh=[100, 50, 200, 40, 0, 200, 100, 100],\nlow_temperature_load_mwh=20\n)\nassert all(\nresults.simulation.columns == [\n'site-import_power_mwh',\n'site-export_power_mwh',\n'spill-electric_generation_mwh',\n'spill-electric_load_mwh',\n'spill-high_temperature_generation_mwh',\n'spill-low_temperature_generation_mwh',\n'spill-high_temperature_load_mwh',\n'spill-low_temperature_load_mwh',\n'spill-gas_consumption_mwh',\n'spill-charge_mwh',\n'spill-discharge_mwh',\n'generator-electric_generation_mwh',\n'generator-gas_consumption_mwh',\n'generator-high_temperature_generation_mwh',\n'generator-low_temperature_generation_mwh',\n'boiler-high_temperature_generation_mwh',\n'boiler-gas_consumption_mwh',\n'valve-high_temperature_load_mwh',\n'valve-low_temperature_generation_mwh',\n'electricity_prices',\n'electricity_carbon_intensities',\n'total-electric_generation_mwh',\n'total-electric_load_mwh',\n'total-high_temperature_generation_mwh',\n'total-low_temperature_generation_mwh',\n'total-high_temperature_load_mwh',\n'total-low_temperature_load_mwh',\n'total-gas_consumption_mwh',\n'total-charge_mwh',\n'total-discharge_mwh',\n'total-spills_mwh',\n'total-losses_mwh',\n'site-electricity_balance_mwh',\n'load-high_temperature_load_mwh',\n'load-low_temperature_load_mwh'\n]\n)\n</code></pre>"},{"location":"how-to/dispatch-assets/#electric-vehicle-charging","title":"Electric Vehicle Charging","text":"<p>Control a number of EV chargers to charge a number of charge events.  </p> <p>Chargers are configured by their size given in <code>charger_mws</code>.  </p> <p>A <code>charge_event</code> is a time interval where an EV can be charged.  This is given as a boolean 2D array, with one binary digit for each charge events, interval pairs.</p> <p>Each charge event has a required amount of electricity <code>charge_event_mwh</code>, that can be delivered when the <code>charge_event</code> is 1.  The model is constrained so that each charge event receives all of it's <code>charge_event_mwh</code>.</p> <p>To optimize two 100 MWe chargers for 4 charge events over 5 intervals:</p> <pre><code>import energypylinear as epl\n#  2 100 MW EV chargers\nasset = epl.evs.EVs(charger_mws=[100, 100], charger_turndown=0.1)\nelectricity_prices = [-100, 50, 30, 50, 40]\ncharge_events = [\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 0],\n[0, 0, 0, 1, 1],\n[0, 1, 0, 0, 0],\n]\ncharge_event_mwh = [50, 100, 30, 40]\nresults = asset.optimize(\nelectricity_prices=electricity_prices,\ncharge_events=charge_events,\ncharge_event_mwh=charge_event_mwh,\n)\nassert all(\nresults.simulation.columns == [\n'site-import_power_mwh',\n'site-export_power_mwh',\n'spill-electric_generation_mwh',\n'spill-electric_load_mwh',\n'spill-high_temperature_generation_mwh',\n'spill-low_temperature_generation_mwh',\n'spill-high_temperature_load_mwh',\n'spill-low_temperature_load_mwh',\n'spill-gas_consumption_mwh',\n'spill-charge_mwh',\n'spill-discharge_mwh',\n'charger-0-charge_mwh',\n'charger-0-charge_binary',\n'charger-1-charge_mwh',\n'charger-1-charge_binary',\n'charge-event-0-charge_mwh',\n'charge-event-1-charge_mwh',\n'charge-event-2-charge_mwh',\n'charge-event-3-charge_mwh',\n'charger-spill-charge_mwh',\n'charger-spill-charge_binary',\n'spill-charge-event-0-charge_mwh',\n'spill-charge-event-1-charge_mwh',\n'spill-charge-event-2-charge_mwh',\n'spill-charge-event-3-charge_mwh',\n'charge-event-0-total-charge_mwh',\n'charge-event-1-total-charge_mwh',\n'charge-event-2-total-charge_mwh',\n'charge-event-3-total-charge_mwh',\n'electricity_prices',\n'electricity_carbon_intensities',\n'total-electric_generation_mwh',\n'total-electric_load_mwh',\n'total-high_temperature_generation_mwh',\n'total-low_temperature_generation_mwh',\n'total-high_temperature_load_mwh',\n'total-low_temperature_load_mwh',\n'total-gas_consumption_mwh',\n'total-charge_mwh',\n'total-discharge_mwh',\n'total-spills_mwh',\n'total-losses_mwh',\n'site-electricity_balance_mwh',\n'load-high_temperature_load_mwh',\n'load-low_temperature_load_mwh'\n]\n)\n</code></pre>"},{"location":"how-to/dispatch-forecast/","title":"Optimize for a Forecast","text":""},{"location":"how-to/dispatch-forecast/#dispatch-for-actuals-vs-dispatch-for-forecasts","title":"Dispatch for Actuals vs. Dispatch for Forecasts","text":"<p><code>energypylinear</code> has the ability to optimize for both actuals and forecasts.</p> <p>The same primitives can be used to model the variance in performance of an asset optimized for actual prices versus forecast prices:</p> <pre><code>import energypylinear as epl\n#  interval data\nelectricity_prices = [100, 50, 200, -100, 0, 200, 100, -100]\nforecasts = [-100, 0, 200, 100, -100, 100, 50, 200]\n#  battery asset\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4, efficiency=0.9)\n#  optimize with perfect foresight\nactual = asset.optimize(electricity_prices=electricity_prices)\n#  optimize to the forecast\nforecast = asset.optimize(electricity_prices=forecasts)\n# create accounts for the two scenarios \nperfect_foresight = epl.get_accounts(actual.interval_data, actual.simulation)\n# in the forecast we use the actual interval_data, not the forecast interval_data\nforecast = epl.get_accounts(actual.interval_data, forecast.simulation)\nvariance = perfect_foresight - forecast\n# cost=-1197.777778 emissions=0.002222221999999996\n</code></pre> <p>See also examples/forecast-accuracy.py.</p>"},{"location":"how-to/dispatch-site/","title":"Dispatching Multiple Assets with the Site API","text":"<p>The site API allows optimizing many assets at the same time.  These assets operate on the same site.</p> <p>Multiple assets can be optimized using an <code>epl.Site</code>, which accepts a list of assets.</p> <p>Below we give some examples of typical configurations of energy assets.</p>"},{"location":"how-to/dispatch-site/#battery-chp-generator","title":"Battery &amp; CHP Generator","text":"<p>We can use a site to optimize an electric battery alongside a gas fired generator:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(assets=[\nepl.Battery(power_mw=2.0, capacity_mwh=4.0),\nepl.Generator(\nelectric_power_max_mw=100,\nelectric_power_min_mw=30,\nelectric_efficiency_pct=0.4\n)\n])\nresults = site.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3\n)\n</code></pre>"},{"location":"how-to/dispatch-site/#fast-slow-battery","title":"Fast &amp; Slow Battery","text":"<p>We can use a site to optimize a fast and slow battery alongside each other:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(assets=[\nepl.Battery(power_mw=4.0, capacity_mwh=1.0),\nepl.Battery(power_mw=2.0, capacity_mwh=4.0),\n])\nresults = site.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3\n)\n</code></pre>"},{"location":"how-to/dispatch-site/#battery-ev-chargers","title":"Battery &amp; EV Chargers","text":"<p>We can use a site to optimize a battery that sits alongside EV chargers:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(assets=[\nepl.Battery(power_mw=2.0, capacity_mwh=4.0),\nepl.evs.EVs(charger_mws=[100, 100], charger_turndown=0.1)\n])\nresults = site.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3,\ncharge_events=[\n[1, 0, 0, 0, 0, 0, 0, 0],\n[0, 1, 1, 1, 0, 0, 0, 0],\n[0, 0, 0, 1, 1, 0, 0, 0],\n[0, 1, 0, 0, 0, 0, 0, 0],\n],\ncharge_event_mwh=[50, 100, 30, 40]\n)\n</code></pre>"},{"location":"how-to/price-carbon/","title":"Optimize for Carbon","text":"<p><code>energypylinear</code> has the ability to optimize for both price and carbon as optimization objectives.</p> <p>This ability comes from two things:</p> <ul> <li>an objective function, which can be either for price or carbon,</li> <li>accounting of both price and carbon emissions.</li> </ul> <p>We can dispatch a battery to minimize carbon emissions by passing in <code>objective='carbon'</code>:</p> <pre><code>import energypylinear as epl\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4, efficiency=0.9)\nresults = asset.optimize(\nelectricity_prices=[100, 50, 200, -100, 0, 200, 100, -100],\nelectricity_carbon_intensities = [0.1, 0.2, 0.1, 0.15, 0.01, 0.7, 0.5, 0.01],\nobjective='carbon'\n)\n</code></pre> <p>We can compare these results above with a simulation that optimizes for price, using a <code>energypylinear.accounting.Account</code> to compare both simulations.  </p> <p>Our optimization for price has a high negative cost.  </p> <p>The optimization for carbon has lower emissions, but at a higher cost:</p> <pre><code>import energypylinear as epl\n#  interval data\nelectricity_prices = [100, 50, 200, -100, 0, 200, 100, -100]\nelectricity_carbon_intensities = [0.1, 0.2, 0.1, 0.15, 0.01, 0.7, 0.5, 0.01]\n#  battery asset\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4, efficiency=0.9)\n#  optimize for money\nprice = asset.optimize(electricity_prices=electricity_prices)\n#  optimize for the planet\ncarbon = asset.optimize(\nelectricity_prices=electricity_prices,\nelectricity_carbon_intensities=electricity_carbon_intensities,\nobjective='carbon'\n)\n#  get an account representing the difference between the two\nprice = epl.get_accounts(\nprice.interval_data,\nprice.simulation,\n)\ncarbon = epl.get_accounts(\ncarbon.interval_data,\ncarbon.simulation,\n)\nprint(price)\n# cost=-1057.777778 emissions=0.08222222199999996 profit=1057.777778\nprint(carbon)\n# cost=-134.44444399999998 emissions=-2.2733333339999997 profit=134.44444399999998\nvariance = price - carbon\nprint(variance)\n# cost=-923.3333339999999 emissions=2.3555555559999997\nprint(-variance.cost / variance.emissions)\n# 391.9811322845319\n</code></pre> <p>The accounting API is in it's first iteration - expect it to change in the future.</p>"}]}