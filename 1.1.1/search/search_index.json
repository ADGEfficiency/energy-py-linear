{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"energy-py-linear","text":"<p>A Python library for optimizing energy assets with mixed-integer linear programming:</p> <ul> <li>electric batteries,</li> <li>combined heat &amp; power (CHP) generators,</li> <li>electric vehicle smart charging,</li> <li>heat pumps,</li> <li>renewable (wind &amp; solar) generators.</li> </ul> <p>Assets &amp; sites can be optimized to either maximize profit or minimize carbon emissions.</p> <p>Energy balances are performed on electricity, high &amp; low temperature heat.</p>"},{"location":"#setup","title":"Setup","text":"<p>Requires Python 3.10+:</p> <pre><code>$ pip install energypylinear\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#asset-api","title":"Asset API","text":"<p>The asset API allows optimizing a single asset at once:</p> <pre><code>import energypylinear as epl\n#  2.0 MW, 4.0 MWh battery\nasset = epl.Battery(\npower_mw=2,\ncapacity_mwh=4,\nefficiency_pct=0.9,\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nexport_electricity_prices=40\n)\nsimulation = asset.optimize()\n</code></pre>"},{"location":"#site-api","title":"Site API","text":"<p>The site API allows optimizing multiple assets together:</p> <pre><code>import energypylinear as epl\nassets = [\n#  2.0 MW, 4.0 MWh battery\nepl.Battery(\npower_mw=2.0,\ncapacity_mwh=4.0\n),\n#  30 MW open cycle generator\nepl.CHP(\nelectric_power_max_mw=100,\nelectric_power_min_mw=30,\nelectric_efficiency_pct=0.4\n),\n#  2 EV chargers &amp; 4 charge events\nepl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 0],\n[0, 0, 0, 1, 1],\n[0, 1, 0, 0, 0],\n],\n),\nepl.Boiler(),\nepl.Valve()\n]\nsite = epl.Site(\nassets=assets,\nelectricity_prices=[100, 50, 200, -100, 0],\nhigh_temperature_load_mwh=[105, 110, 120, 110, 105],\nlow_temperature_load_mwh=[105, 110, 120, 110, 105]\n)\nsimulation = site.optimize()\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#111","title":"1.1.1","text":""},{"location":"changelog/#bugs","title":"Bugs","text":"<p>Fixed a bug where logger was making a <code>./logs</code> directory even when <code>enable_file_logging</code> was set to false.</p> <p>Fixed the flaky test of battery export prices by reducing optimizer tolerance to 0 in the test.</p>"},{"location":"changelog/#other-changes","title":"Other Changes","text":"<p>Removed documentation <code>.png</code> images from <code>main</code>.</p>"},{"location":"changelog/#110","title":"1.1.0","text":""},{"location":"changelog/#export-electricity-prices","title":"Export Electricity Prices","text":"<p>Assets can now accept export electricity prices - these are an optional time series that can either be a constant value or interval data:</p> <pre><code>asset = epl.Battery(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nexport_electricity_prices=40\n)\n</code></pre> <p>These export electricity prices are used to calculate the value of electricity exported from site.</p>"},{"location":"changelog/#optimizer-config","title":"Optimizer Config","text":"<p>The <code>.optimize()</code> method of assets now accepts an <code>epl.OptimizerConfig</code> object, which allows configuration of the CBC optimizer used by Pulp:</p> <pre><code>asset.optimize(\noptimizer_config=epl.OptimizerConfig(timeout=60, relative_tolerance=0.05)\n)\n</code></pre>"},{"location":"changelog/#bugs_1","title":"Bugs","text":"<p>Fixed a bug on the <code>allow_infeasible</code> flag in <code>epl.Site.optimize</code>.</p> <p>Fixed a bug on the <code>export_limit_mw</code> in <code>epl.Site.__init__</code>.</p>"},{"location":"changelog/#netting-off-battery-charge-and-discharge","title":"Netting Off Battery Charge and Discharge","text":"<p><code>energypylinear</code> has the ability to constrain battery charge or discharge into a single interval, using binary variables that are linked to the charge and discharge energy.</p> <p>By default these were turned off, because it slows down the optimization. The effect on the site electricity balance was zero, as the charge and discharge energy were netted off in the balance.</p> <p>However, as the battery losses are a percentage of battery charge, this led to situations where when electricity prices were negative, the optimizer would be incentivized to have a large simultaneous charge and discharge.  This would also lead to the situation where the losses calculations were correct as a percentage of battery charge, but not of battery net charge.</p> <p>The solution is to remove the flag that allowed toggling of these binary variables on and off - this now means that the battery model always runs with binary variables limiting only one of charge or discharge to occur in a single interval.</p>"},{"location":"changelog/#100","title":"1.0.0","text":""},{"location":"changelog/#add-renewable-generator-asset","title":"Add Renewable Generator Asset","text":"<p>The <code>epl.RenewableGenerator</code> asset models controllable renewable generation like solar or wind.</p> <pre><code>import energypylinear as epl\nasset = epl.RenewableGenerator(\nelectricity_prices=[1.0, -0.5],\nelectric_generation_mwh=[100, 100],\nelectric_generation_lower_bound_pct=0.5,\nname=\"wind\",\n)\n</code></pre> <p>This asset can clip the lower bound of the generation to a percentage of the total available generation.</p> <p>This allows the renewable generator asset to reduce its generation during periods of negative prices or carbon intensities.</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/#interval-data-rework","title":"Interval Data Rework","text":"<p>v1.0.0 moves the interval data arguments to asset from <code>asset.optimize</code> to <code>asset.__init__</code>:</p> <pre><code>import energypylinear as epl\n#  the old way\nasset = epl.Battery()\nsimulation = asset.optimize(electricity_prices=[10, -50, 200, -50, 200])\n#  the new way\nasset = epl.Battery(electricity_prices=[10, -50, 200, -50, 200])\nsimulation = asset.optimize()\n</code></pre> <p>The reasons for this change is that it allows different asset specific interval data to be specified when using the <code>epl.Site</code> API.</p>"},{"location":"changelog/#other-breaking-changes","title":"Other Breaking Changes","text":"<p><code>electricity_prices</code> is now optional - only one of <code>electricity_prices</code> or <code>elelectriciy_carbon_intensities</code> must be specified during the initialization of either an asset or site.</p> <p>For the <code>epl.Battery</code> asset, the argument <code>efficiency</code> has been renamed <code>efficiency_pct</code>.</p> <p>The <code>epl.Generator</code> asset has been renamed to <code>epl.CHP</code>.</p> <p>The accounting API has been reworked:</p> <pre><code>account = epl.get_accounts(\nforecasts.results,\nprice_results=actuals.results,\nverbose=False\n)\n</code></pre> <p>The simulation results object has been changed - the results <code>pd.Dataframe</code> is now the <code>.results</code> attribute on the simulation result object:</p> <pre><code>#  old way\nresults = asset.optimize()\nresults = results.simulation\n#  new way\nsimulation = asset.optimize()\nresults = simulation.results\n</code></pre>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<p>Fixed a bug in the documentation for optimizing for price and carbon.</p> <p>Added the heat pump asset to the <code>epl.Site</code> API.</p>"},{"location":"changelog/#documentation","title":"Documentation","text":"<p>Expanded the asset documentation from a single file into separate files, one per asset. Moved examples into the asset documentation.</p> <p>Renamed the optimization section into <code>How To</code>.</p>"},{"location":"changelog/#other-changes_1","title":"Other Changes","text":"<p>Adopted semantic versioning.</p> <p>Moved changelog into docs/changelog.</p> <p>Updated versions of Pydantic, Pandas &amp; Numpy.</p>"},{"location":"changelog/#021","title":"0.2.1","text":"<p>Added the <code>epl.HeatPump</code> asset.</p>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>Added bi-directional V2G charging to the EV asset.</p>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>Added the site API, add hosted documentation.</p>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>Allowed Python 3.11.</p>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>Added <code>energypylinear</code> to PyPi.</p>"},{"location":"getting-started/","title":"hi","text":""},{"location":"performance/","title":"Performance","text":"<p>This page is in development - you shouldn't be here!</p>"},{"location":"performance/#battery","title":"Battery","text":""},{"location":"performance/#evs","title":"EVs","text":""},{"location":"assets/battery/","title":"Battery","text":"<p>Dispatch an electric battery operating in wholesale price arbitrage using <code>epl.Battery</code>:</p> <pre><code>import energypylinear as epl\n#  optimize a 2.0 MW, 4.0 MWh battery for money\nasset = epl.Battery(\npower_mw=2,\ncapacity_mwh=4,\nefficiency_pct=0.9,\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3,\n)\nsimulation = asset.optimize(objective=\"price\")\n#  optimize a 1.0 MW, 3.0 MWh battery for carbon\nasset = epl.Battery(\npower_mw=1,\ncapacity_mwh=3,\nefficiency_pct=0.9,\nelectricity_carbon_intensities=[0.1, 0.2, 0.1, 0.15, 0.01, 0.7, 0.5, 0.01],\nfreq_mins=60,\ninitial_charge_mwh=0,\nfinal_charge_mwh=0,\n)\nsimulation = asset.optimize(objective=\"carbon\")\nassert all(\nsimulation.results.columns\n== [\n\"site-import_power_mwh\",\n\"site-export_power_mwh\",\n\"site-electricity_prices\",\n\"site-electricity_carbon_intensities\",\n\"site-high_temperature_load_mwh\",\n\"site-low_temperature_load_mwh\",\n\"site-low_temperature_generation_mwh\",\n\"site-gas_prices\",\n\"site-electric_load_mwh\",\n\"spill-electric_generation_mwh\",\n\"spill-electric_load_mwh\",\n\"spill-high_temperature_generation_mwh\",\n\"spill-low_temperature_generation_mwh\",\n\"spill-high_temperature_load_mwh\",\n\"spill-low_temperature_load_mwh\",\n\"spill-gas_consumption_mwh\",\n\"battery-electric_charge_mwh\",\n\"battery-electric_charge_binary\",\n\"battery-electric_discharge_mwh\",\n\"battery-electric_discharge_binary\",\n\"battery-electric_loss_mwh\",\n\"battery-electric_initial_charge_mwh\",\n\"battery-electric_final_charge_mwh\",\n\"total-electric_generation_mwh\",\n\"total-electric_load_mwh\",\n\"total-high_temperature_generation_mwh\",\n\"total-low_temperature_generation_mwh\",\n\"total-high_temperature_load_mwh\",\n\"total-low_temperature_load_mwh\",\n\"total-gas_consumption_mwh\",\n\"total-electric_charge_mwh\",\n\"total-electric_discharge_mwh\",\n\"total-spills_mwh\",\n\"total-electric_loss_mwh\",\n\"site-electricity_balance_mwh\",\n]\n)\n</code></pre> <p>The battery will charge with electricity at low prices &amp; carbon intensities, and discharge at high prices &amp; carbon intensities.</p> <p>An efficiency penalty is applied to the battery charge energy (energy is lost during charging).</p>"},{"location":"assets/chp/","title":"CHP","text":"<p>Dispatch a CHP (combined heat &amp; power) generator to generate electricity, high &amp; low temperature heat from natural gas.</p> <p>The <code>epl.CHP</code> model can be configured with electric, high and low temperature thermal efficiencies.</p> <p>This allows modelling both gas engines and gas turbines.</p> <p>When optimizing, we can use interval data for the high and low temperature loads.  These thermal loads will be met by gas boilers if the CHP chooses not to generate, or cannot meet thermal demands.  High temperature heat can be let-down into low temperature heat.</p> <p>The <code>epl.CHP</code> is allowed to dump both high temperature and low temperature heat.</p> <p>The high and low temperature heat demands are supplied alongside the electricity prices when optimizing:</p> <pre><code>import energypylinear as epl\n#  100 MWe gas turbine\nasset = epl.CHP(\nelectric_power_max_mw=100,\nelectric_power_min_mw=50,\nelectric_efficiency_pct=0.3,\nhigh_temperature_efficiency_pct=0.5,\n)\n#  100 MWe gas engine\nasset = epl.CHP(\nelectric_power_max_mw=100,\nelectric_power_min_mw=10,\nelectric_efficiency_pct=0.4,\nhigh_temperature_efficiency_pct=0.2,\nlow_temperature_efficiency_pct=0.2,\nelectricity_prices=[100, 50, 200, -100, 0, 200, 100, -100],\nhigh_temperature_load_mwh=[100, 50, 200, 40, 0, 200, 100, 100],\nlow_temperature_load_mwh=20,\n)\nsimulation = asset.optimize()\nassert all(\nsimulation.results.columns\n== [\n\"site-import_power_mwh\",\n\"site-export_power_mwh\",\n\"site-electricity_prices\",\n\"site-electricity_carbon_intensities\",\n\"site-high_temperature_load_mwh\",\n\"site-low_temperature_load_mwh\",\n\"site-low_temperature_generation_mwh\",\n\"site-gas_prices\",\n\"site-electric_load_mwh\",\n\"spill-electric_generation_mwh\",\n\"spill-electric_load_mwh\",\n\"spill-high_temperature_generation_mwh\",\n\"spill-low_temperature_generation_mwh\",\n\"spill-high_temperature_load_mwh\",\n\"spill-low_temperature_load_mwh\",\n\"spill-gas_consumption_mwh\",\n\"chp-electric_generation_mwh\",\n\"chp-gas_consumption_mwh\",\n\"chp-high_temperature_generation_mwh\",\n\"chp-low_temperature_generation_mwh\",\n\"boiler-high_temperature_generation_mwh\",\n\"boiler-gas_consumption_mwh\",\n\"valve-high_temperature_load_mwh\",\n\"valve-low_temperature_generation_mwh\",\n\"total-electric_generation_mwh\",\n\"total-electric_load_mwh\",\n\"total-high_temperature_generation_mwh\",\n\"total-low_temperature_generation_mwh\",\n\"total-high_temperature_load_mwh\",\n\"total-low_temperature_load_mwh\",\n\"total-gas_consumption_mwh\",\n\"total-electric_charge_mwh\",\n\"total-electric_discharge_mwh\",\n\"total-spills_mwh\",\n\"total-electric_loss_mwh\",\n\"site-electricity_balance_mwh\",\n]\n)\n</code></pre>"},{"location":"assets/evs/","title":"Electric Vehicle Charging","text":"<p>Control a number of EV chargers to charge a number of charge events.</p> <p>Chargers are configured by their size given in <code>charger_mws</code>.</p> <p>A <code>charge_event</code> is a time interval where an EV can be charged.  This is given as a boolean 2D array, with one binary digit for each charge events, interval pairs.</p> <p>Each charge event has a required amount of electricity <code>charge_event_mwh</code>, that can be delivered when the <code>charge_event</code> is 1.  The model is constrained so that each charge event receives all of it's <code>charge_event_mwh</code>.</p> <p>To optimize two 100 MWe chargers for 4 charge events over 5 intervals:</p> <pre><code>import energypylinear as epl\nelectricity_prices = [-100, 50, 30, 50, 40]\ncharge_events = [\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 0],\n[0, 0, 0, 1, 1],\n[0, 1, 0, 0, 0],\n]\n#  2 100 MW EV chargers\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30, 40],\ncharger_turndown=0.1,\nelectricity_prices=electricity_prices,\ncharge_events=charge_events,\n)\nsimulation = asset.optimize()\nassert all(\nsimulation.results.columns\n== [\n\"site-import_power_mwh\",\n\"site-export_power_mwh\",\n\"site-electricity_prices\",\n\"site-electricity_carbon_intensities\",\n\"site-high_temperature_load_mwh\",\n\"site-low_temperature_load_mwh\",\n\"site-low_temperature_generation_mwh\",\n\"site-gas_prices\",\n\"site-electric_load_mwh\",\n\"spill-electric_generation_mwh\",\n\"spill-electric_load_mwh\",\n\"spill-high_temperature_generation_mwh\",\n\"spill-low_temperature_generation_mwh\",\n\"spill-high_temperature_load_mwh\",\n\"spill-low_temperature_load_mwh\",\n\"spill-gas_consumption_mwh\",\n\"evs-charger-0-electric_charge_mwh\",\n\"evs-charger-0-electric_charge_binary\",\n\"evs-charger-0-electric_discharge_mwh\",\n\"evs-charger-0-electric_discharge_binary\",\n\"evs-charger-1-electric_charge_mwh\",\n\"evs-charger-1-electric_charge_binary\",\n\"evs-charger-1-electric_discharge_mwh\",\n\"evs-charger-1-electric_discharge_binary\",\n\"evs-charge-event-0-electric_charge_mwh\",\n\"evs-charge-event-0-electric_discharge_mwh\",\n\"evs-charge-event-0-electric_loss_mwh\",\n\"evs-charge-event-1-electric_charge_mwh\",\n\"evs-charge-event-1-electric_discharge_mwh\",\n\"evs-charge-event-1-electric_loss_mwh\",\n\"evs-charge-event-2-electric_charge_mwh\",\n\"evs-charge-event-2-electric_discharge_mwh\",\n\"evs-charge-event-2-electric_loss_mwh\",\n\"evs-charge-event-3-electric_charge_mwh\",\n\"evs-charge-event-3-electric_discharge_mwh\",\n\"evs-charge-event-3-electric_loss_mwh\",\n\"evs-charge-event-0-initial_soc_mwh\",\n\"evs-charge-event-1-initial_soc_mwh\",\n\"evs-charge-event-2-initial_soc_mwh\",\n\"evs-charge-event-3-initial_soc_mwh\",\n\"evs-charge-event-0-final_soc_mwh\",\n\"evs-charge-event-1-final_soc_mwh\",\n\"evs-charge-event-2-final_soc_mwh\",\n\"evs-charge-event-3-final_soc_mwh\",\n\"evs-charger-spill-evs-electric_charge_mwh\",\n\"evs-charger-spill-evs-electric_charge_binary\",\n\"evs-charger-spill-evs-electric_discharge_mwh\",\n\"evs-charger-spill-evs-electric_discharge_binary\",\n\"total-electric_generation_mwh\",\n\"total-electric_load_mwh\",\n\"total-high_temperature_generation_mwh\",\n\"total-low_temperature_generation_mwh\",\n\"total-high_temperature_load_mwh\",\n\"total-low_temperature_load_mwh\",\n\"total-gas_consumption_mwh\",\n\"total-electric_charge_mwh\",\n\"total-electric_discharge_mwh\",\n\"total-spills_mwh\",\n\"total-electric_loss_mwh\",\n\"site-electricity_balance_mwh\",\n]\n)\n</code></pre>"},{"location":"assets/heat-pump/","title":"Heat Pump","text":"<p>Optimize the operation of a heat pump.  A heat pump uses electricity to convert low temperature heat to high temperature heat.</p> <p>When using <code>epl.HeatPump.optimize</code>, the alternative to the heat pump is generating high temperature heat from a gas boiler.  Under the hood of <code>epl.HeatPump.optimize</code>, a <code>epl.Boiler</code> asset is used to supply the balance of high temperature heat demand of the site.</p> <p>The gas price is important as the alternative to using a heat pump to supply the <code>high_temperature_load_mwh</code> is using a natural gas boiler.</p> <p>In order for the heat pump to work, it needs to have both a source of low temperature heat and a sink of high temperature heat.</p> <p>The <code>high_temperature_load_mwh</code> is the amount of heat consumed by the site, and <code>low_temperature_generation_mwh</code> is the amount of available low temperature heat.</p> <pre><code>import energypylinear as epl\nasset = epl.HeatPump(\nelectric_power_mw=1.0,\ncop=2,\ngas_prices=20,\nelectricity_prices=[100, -100],\nhigh_temperature_load_mwh=3.0,\nlow_temperature_generation_mwh=3.0,\n)\nsimulation = asset.optimize(verbose=False)\nprint(\nsimulation.results[\n[\n\"site-electricity_prices\",\n\"heat-pump-electric_load_mwh\",\n\"heat-pump-low_temperature_load_mwh\",\n\"heat-pump-high_temperature_generation_mwh\",\n]\n]\n)\nassert all(\nsimulation.results.columns\n== [\n\"site-import_power_mwh\",\n\"site-export_power_mwh\",\n\"site-electricity_prices\",\n\"site-electricity_carbon_intensities\",\n\"site-high_temperature_load_mwh\",\n\"site-low_temperature_load_mwh\",\n\"site-low_temperature_generation_mwh\",\n\"site-gas_prices\",\n\"site-electric_load_mwh\",\n\"spill-electric_generation_mwh\",\n\"spill-electric_load_mwh\",\n\"spill-high_temperature_generation_mwh\",\n\"spill-low_temperature_generation_mwh\",\n\"spill-high_temperature_load_mwh\",\n\"spill-low_temperature_load_mwh\",\n\"spill-gas_consumption_mwh\",\n\"boiler-high_temperature_generation_mwh\",\n\"boiler-gas_consumption_mwh\",\n\"valve-high_temperature_load_mwh\",\n\"valve-low_temperature_generation_mwh\",\n\"heat-pump-electric_load_mwh\",\n\"heat-pump-low_temperature_load_mwh\",\n\"heat-pump-high_temperature_generation_mwh\",\n\"total-electric_generation_mwh\",\n\"total-electric_load_mwh\",\n\"total-high_temperature_generation_mwh\",\n\"total-low_temperature_generation_mwh\",\n\"total-high_temperature_load_mwh\",\n\"total-low_temperature_load_mwh\",\n\"total-gas_consumption_mwh\",\n\"total-electric_charge_mwh\",\n\"total-electric_discharge_mwh\",\n\"total-spills_mwh\",\n\"total-electric_loss_mwh\",\n\"site-electricity_balance_mwh\",\n]\n)\n</code></pre> <pre><code>{\n    'n_spills': 1,\n    'spill_columns': 8,\n    'spills': {'spill-low_temperature_load_mwh': 5.0},\n    'event': 'warn_spills',\n    'timestamp': '2023-09-08T00:41:33.743617Z',\n    'logger':'default_logger',\n    'level': 'warning'\n}\n   site-electricity_prices  heat-pump-electric_load_mwh  heat-pump-low_temperature_load_mwh  heat-pump-high_temperature_generation_mwh\n0                      100                          0.0                                 0.0                                        0.0\n1                     -100                          1.0                                 1.0                                        2.0\n</code></pre> <p>Under the hood the heat pump asset also includes a <code>epl.Spill</code>, which allows dumping of excess low temperature heat, and a <code>epl.Valve</code> to allow high temperature heat to flow into low temperature heat.</p> <p>The combination of a <code>epl.Spill</code>, <code>epl.Valve</code> and negative electricity prices can lead to the heat pump using electricity to generate high temperature heat which is then dumped as low temperature heat.  For this reason the <code>epl.HeatPump</code> asset includes a <code>include_valve: bool</code> option to turn off the valve.</p> <p>You could also setup an <code>epl.Site</code> with other assets that generate high temperature heat to explore different tradeoffs (such as a heat pump using low temperature heat from a CHP system).</p>"},{"location":"assets/renewable-generator/","title":"Renewable Generator","text":"<p>Dispatch an renewable generator operating in wholesale price arbitrage using <code>epl.RenewableGenerator</code>.</p> <p>This asset type is suitable for modelling either wind or solar generators.</p> <pre><code>import energypylinear as epl\nasset = epl.RenewableGenerator(\nelectricity_prices=[1.0, -0.5],\nelectric_generation_mwh=[100, 100],\nelectric_generation_lower_bound_pct=0.5,\nname=\"wind\",\n)\nsimulation = asset.optimize(objective=\"price\")\nassert all(\nsimulation.results.columns\n== [\n\"site-import_power_mwh\",\n\"site-export_power_mwh\",\n\"site-electricity_prices\",\n\"site-electricity_carbon_intensities\",\n\"site-high_temperature_load_mwh\",\n\"site-low_temperature_load_mwh\",\n\"site-low_temperature_generation_mwh\",\n\"site-gas_prices\",\n\"site-electric_load_mwh\",\n\"wind-electric_generation_mwh\",\n\"total-electric_generation_mwh\",\n\"total-electric_load_mwh\",\n\"total-high_temperature_generation_mwh\",\n\"total-low_temperature_generation_mwh\",\n\"total-high_temperature_load_mwh\",\n\"total-low_temperature_load_mwh\",\n\"total-gas_consumption_mwh\",\n\"total-electric_charge_mwh\",\n\"total-electric_discharge_mwh\",\n\"total-spills_mwh\",\n\"total-electric_loss_mwh\",\n\"site-electricity_balance_mwh\",\n]\n)\n</code></pre> <p>This renewable generator will turn down when electricity prices are negative.</p>"},{"location":"how-to/dispatch-forecast/","title":"Optimize for a Forecast","text":"<p><code>energypylinear</code> has the ability to optimize for both actuals &amp; forecasts.</p> <p>An asset (or site) can be used to model the variance between optimizing for actual &amp; forecast prices.</p>"},{"location":"how-to/dispatch-forecast/#setup-interval-data","title":"Setup Interval Data","text":"<pre><code>electricity_prices = [100, 50, 200, -100, 0, 200, 100, -100]\nforecasts = [-100, 0, 200, 100, -100, 100, 50, 200]\n</code></pre>"},{"location":"how-to/dispatch-forecast/#optimize-with-perfect-foresight","title":"Optimize with Perfect Foresight","text":"<pre><code>import energypylinear as epl\nasset = epl.Battery(\npower_mw=2,\ncapacity_mwh=4,\nefficiency_pct=0.9,\nelectricity_prices=electricity_prices\n)\nactual = asset.optimize(verbose=False)\nperfect_foresight = epl.get_accounts(actual.results, verbose=False)\nprint(f\"{perfect_foresight=}\")\n</code></pre> <pre><code>perfect_foresight=&lt;Accounts profit=1037.78 emissions=0.0622&gt;\n</code></pre>"},{"location":"how-to/dispatch-forecast/#optimize-to-a-forecast","title":"Optimize to a Forecast","text":"<pre><code>import energypylinear as epl\nasset = epl.Battery(\npower_mw=2,\ncapacity_mwh=4,\nefficiency_pct=0.9,\nelectricity_prices=forecasts\n)\nforecast = asset.optimize(verbose=False)\nforecast_account = epl.get_accounts(\nforecast.results,\nprice_results=actual.results,\nverbose=False\n)\nprint(f\"{forecast_account=}\")\n</code></pre> <pre><code>forecast_account=&lt;Accounts profit=-140.00 emissions=0.0800&gt;\n</code></pre>"},{"location":"how-to/dispatch-forecast/#calculate-variance-between-accounts","title":"Calculate Variance Between Accounts","text":"<pre><code>variance = perfect_foresight - forecast_account\nprint(f\"{variance=}\")\n</code></pre> <pre><code>variance=&lt;Account profit=1177.78 emissions=-0.0178&gt;\n</code></pre>"},{"location":"how-to/dispatch-forecast/#full-example","title":"Full Example","text":"<pre><code>import io\nimport pandas as pd\nimport energypylinear as epl\n#  price and forecast csv data\nraw = \"\"\"\nTimestamp,Trading Price [$/MWh],Predispatch Forecast [$/MWh]\n2018-07-01 17:00:00,177.11,97.58039000000001\n2018-07-01 17:30:00,135.31,133.10307\n2018-07-01 18:00:00,143.21,138.59978999999998\n2018-07-01 18:30:00,116.25,128.09559\n2018-07-01 19:00:00,99.97,113.29413000000001\n2018-07-01 19:30:00,99.71,113.95063\n2018-07-01 20:00:00,97.81,105.5491\n2018-07-01 20:30:00,96.1,102.99768\n2018-07-01 21:00:00,98.55,106.34366000000001\n2018-07-01 21:30:00,95.78,91.82700000000001\n2018-07-01 22:00:00,98.46,87.45\n2018-07-01 22:30:00,91.88,85.65775\n2018-07-01 23:00:00,91.69,85.0\n2018-07-01 23:30:00,101.2,85.0\n2018-07-02 00:00:00,139.55,80.99999\n2018-07-02 00:30:00,102.9,75.85762\n2018-07-02 01:00:00,83.86,67.86758\n2018-07-02 01:30:00,71.1,70.21946\n2018-07-02 02:00:00,60.35,62.151\n2018-07-02 02:30:00,56.01,62.271919999999994\n2018-07-02 03:00:00,51.22,56.79063000000001\n2018-07-02 03:30:00,48.55,53.8532\n2018-07-02 04:00:00,55.17,53.52591999999999\n2018-07-02 04:30:00,56.21,49.57504\n2018-07-02 05:00:00,56.32,48.42244\n2018-07-02 05:30:00,58.79,54.15495\n2018-07-02 06:00:00,73.32,58.01054\n2018-07-02 06:30:00,80.89,68.31508000000001\n2018-07-02 07:00:00,88.43,85.0\n2018-07-02 07:30:00,201.43,119.73926999999999\n2018-07-02 08:00:00,120.33,308.88984\n2018-07-02 08:30:00,113.26,162.32117\n\"\"\"\ndata = pd.read_csv(io.StringIO(raw))\n#  optimize for actuals\nasset = epl.Battery(\npower_mw=2,\ncapacity_mwh=4,\nefficiency_pct=0.9,\nelectricity_prices=data[\"Trading Price [$/MWh]\"].values,\nfreq_mins=30,\n)\nactuals = asset.optimize(verbose=False)\n#  optimize for forecasts\nasset = epl.Battery(\npower_mw=2,\ncapacity_mwh=4,\nefficiency_pct=0.9,\nelectricity_prices=data[\"Predispatch Forecast [$/MWh]\"].values,\nfreq_mins=30,\n)\nforecasts = asset.optimize(verbose=False)\n#  calculate the variance between accounts\nactual_account = epl.get_accounts(\nactuals.results, verbose=False\n)\nforecast_account = epl.get_accounts(\nforecasts.results,\nprice_results=actuals.results,\nverbose=False\n)\nvariance = actual_account - forecast_account\nprint(f\"actuals: {actual_account}\")\nprint(f\"forecasts: {forecast_account}\")\nprint(f\"variance: {variance}\")\nprint(\nf\"\\nforecast error: $ {-1 * variance.cost:2.2f} pct: {100 * variance.cost / actual_account.cost:2.1f} %\"\n)\n</code></pre> <pre><code>actuals: &lt;Accounts profit=325.82 emissions=0.0644&gt;\nforecasts: &lt;Accounts profit=232.85 emissions=0.0544&gt;\nvariance: &lt;Account profit=92.97 emissions=0.0100&gt;\n\nforecast error: $ 92.97 pct: 28.5 %\n</code></pre>"},{"location":"how-to/dispatch-site/","title":"Multiple Assets with the Site API","text":"<p>The site API allows optimizing many assets at the same time.</p> <p>Multiple assets can be optimized using a single <code>epl.Site</code>, which accepts a list of assets.</p> <p>Below we give some examples of typical configurations of energy assets.</p>"},{"location":"how-to/dispatch-site/#battery-chp","title":"Battery &amp; CHP","text":"<p>We can use a site to optimize an electric battery alongside a gas fired CHP:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(\nassets=[\nepl.Battery(\npower_mw=2.0,\ncapacity_mwh=4.0,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3\n),\nepl.CHP(\nelectric_power_max_mw=100,\nelectric_power_min_mw=30,\nelectric_efficiency_pct=0.4,\n),\n],\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\n)\nsimulation = site.optimize()\n</code></pre>"},{"location":"how-to/dispatch-site/#fast-slow-battery","title":"Fast &amp; Slow Battery","text":"<p>We can use a site to optimize a fast and slow battery alongside each other:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(\nassets=[\nepl.Battery(\npower_mw=4.0,\ncapacity_mwh=1.0,\ninitial_charge_mwh=1,\nfinal_charge_mwh=1\n),\nepl.Battery(\npower_mw=2.0,\ncapacity_mwh=4.0,\ninitial_charge_mwh=4.0,\nfinal_charge_mwh=0.0,\nname=\"battery-2\",\n),\n],\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\n)\nsimulation = site.optimize()\n</code></pre>"},{"location":"how-to/dispatch-site/#battery-ev-chargers","title":"Battery &amp; EV Chargers","text":"<p>We can use a site to optimize a battery that sits alongside EV chargers:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(\nassets=[\nepl.Battery(\npower_mw=2.0,\ncapacity_mwh=4.0,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3,\n),\nepl.EVs(\nchargers_power_mw=[100, 100],\ncharger_turndown=0.1,\ncharge_events=[\n[1, 0, 0, 0, 0, 0, 0, 0],\n[0, 1, 1, 1, 0, 0, 0, 0],\n[0, 0, 0, 1, 1, 0, 0, 0],\n[0, 1, 0, 0, 0, 0, 0, 0],\n],\ncharge_events_capacity_mwh=[50, 100, 30, 40],\n),\n],\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\n)\nsimulation = site.optimize()\n</code></pre>"},{"location":"how-to/price-carbon/","title":"Optimize for Carbon","text":"<p><code>energypylinear</code> has the ability to optimize for both price and carbon as optimization objectives.</p> <p>This ability comes from two things - an objective function, which can be either for price or carbon, along with accounting of both price and carbon emissions.</p> <p>We can dispatch a battery to minimize carbon emissions by passing in <code>objective='carbon'</code>:</p>"},{"location":"how-to/price-carbon/#setup-interval-data","title":"Setup Interval Data","text":"<pre><code>import energypylinear as epl\nelectricity_prices = [100, 50, 200, -100, 0, 200, 100, -100]\nelectricity_carbon_intensities = [0.1, 0.2, 0.1, 0.15, 0.01, 0.7, 0.5, 0.01]\n</code></pre>"},{"location":"how-to/price-carbon/#optimize-for-carbon","title":"Optimize for Carbon","text":"<pre><code>asset = epl.Battery(\npower_mw=2,\ncapacity_mwh=4,\nefficiency_pct=0.9,\nelectricity_prices=electricity_prices,\nelectricity_carbon_intensities=electricity_carbon_intensities,\n)\ncarbon = asset.optimize(objective=\"carbon\", verbose=False)\ncarbon_account = epl.get_accounts(carbon.results, verbose=False)\nprint(f\"{carbon_account=}\")\n</code></pre> <pre><code>carbon_account=&lt;Accounts profit=134.44 emissions=-2.2733&gt;\n</code></pre>"},{"location":"how-to/price-carbon/#optimize-for-money","title":"Optimize for Money","text":"<p>We can compare these results above with a simulation that optimizes for price, using a <code>energypylinear.accounting.Account</code> to compare both simulations.</p> <p>Our optimization for price has a high negative cost.</p> <p>The optimization for carbon has lower emissions, but at a higher cost:</p> <pre><code>asset = epl.Battery(\npower_mw=2,\ncapacity_mwh=4,\nefficiency_pct=0.9,\nelectricity_prices=electricity_prices,\nelectricity_carbon_intensities=electricity_carbon_intensities,\n)\nprice = asset.optimize(\nobjective=\"price\",\nverbose=False\n)\nprice_account = epl.get_accounts(price.results, verbose=False)\nprint(f\"{price_account=}\")\n</code></pre> <pre><code>price_account=&lt;Accounts profit=1037.78 emissions=-1.6578&gt;\n</code></pre>"},{"location":"how-to/price-carbon/#calculate-variance-between-accounts","title":"Calculate Variance Between Accounts","text":"<pre><code>variance = price_account - carbon_account\nprint(f\"{variance=}\")\nprint(f\"{-variance.cost / variance.emissions:.2f} $/tC\")\n</code></pre> <pre><code>variance=&lt;Account profit=903.33 emissions=0.6156&gt;\n1467.51 $/tC\n</code></pre>"},{"location":"validation/battery/","title":"Battery","text":"<p>A natural response when you get access to something someone else built is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the battery asset.</p>"},{"location":"validation/battery/#price-dispatch-behaviour","title":"Price Dispatch Behaviour","text":"<p>Let's optimize a battery using a sequence of five prices.</p> <p>We expect that the battery will charge when prices are low, and will discharge when prices are high.</p> <p>In <code>energypylinear</code>, a positive site electricity balance is importing, and a negative site electricity balance is exporting.</p> <pre><code>import energypylinear as epl\nasset = epl.Battery(\nelectricity_prices=[10, -50, 200, -50, 200],\n)\nsimulation = asset.optimize(verbose=False)\nprint(simulation.results[[\"site-electricity_prices\", \"site-electricity_balance_mwh\"]])\n</code></pre> <pre><code>   site-electricity_prices  site-electricity_balance_mwh\n0                       10                      0.444444\n1                      -50                      2.000000\n2                      200                     -2.000000\n3                      -50                      2.000000\n4                      200                     -2.000000\n</code></pre> <p>As expected, the battery charges (with a site that is positive) when prices are low and discharges (with a negative site electricity balance) when prices are high.</p> <p>Now let's change the prices and see how the dispatch changes:</p> <pre><code>import energypylinear as epl\nasset = epl.Battery(\nelectricity_prices=[200, -50, -50, 200, 220],\n)\nsimulation = asset.optimize(verbose=False)\nprint(simulation.results[[\"site-electricity_prices\", \"site-electricity_balance_mwh\"]])\n</code></pre> <pre><code>   site-electricity_prices  site-electricity_balance_mwh\n0                      200                           0.0\n1                      -50                           2.0\n2                      -50                           2.0\n3                      200                          -1.6\n4                      220                          -2.0\n</code></pre> <p>As expected, the battery continues to charge during low electricity price intervals, and discharge when electricity prices are high.</p>"},{"location":"validation/battery/#energy-balance","title":"Energy Balance","text":"<p>Let's return to our original set of prices and check the energy balance of the battery:</p> <pre><code>import pandas as pd\nimport energypylinear as epl\npd.set_option(\"display.max_columns\", 30)\npd.set_option(\"display.width\", 400)\nasset = epl.Battery(\nelectricity_prices=[10, -50, 200, -50, 200],\n)\nsimulation = asset.optimize(verbose=False)\nchecks = epl.check_results(simulation.results, verbose=False)\nbalance = checks[\"electricity-balance\"]\nprint(balance)\n</code></pre> <pre><code>      input  accumulation  output  balance    import  generation  export  load    charge  discharge      loss  spills  soc\n0  0.444444     -0.444444     0.0     True  0.444444         0.0     0.0   0.0  0.444444        0.0  0.044444     0.0  0.0\n1  2.000000     -2.000000     0.0     True  2.000000         0.0     0.0   0.0  2.000000        0.0  0.200000     0.0  0.0\n2  0.000000      2.000000     2.0     True  0.000000         0.0     2.0   0.0  0.000000        2.0  0.000000     0.0  0.0\n3  2.000000     -2.000000     0.0     True  2.000000         0.0     0.0   0.0  2.000000        0.0  0.200000     0.0  0.0\n4  0.000000      2.000000     2.0     True  0.000000         0.0     2.0   0.0  0.000000        2.0  0.000000     0.0  0.0\n</code></pre> <p>In the first interval, we charge the battery with <code>0.444444 MWh</code> - <code>0.4 MWh</code> goes into increasing the battery state of charge from <code>0.0 MWh</code> to <code>0.4 MWh</code>, with the balance <code>0.044444 MWh</code> going to battery losses.</p>"},{"location":"validation/battery/#battery-efficiency","title":"Battery Efficiency","text":"<p>We can validate the performance of the battery efficiency by checking the losses across different battery efficiencies:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport energypylinear as epl\nnp.random.seed(42)\nprices = np.random.uniform(-100, 100, 12) + 100\nout = []\nfor efficiency_pct in [1.0, 0.9, 0.8]:\nasset = epl.Battery(\npower_mw=4,\ncapacity_mwh=10,\nefficiency_pct=efficiency_pct,\nelectricity_prices=prices,\n)\nsimulation = asset.optimize(\nobjective=\"price\",\nverbose=False\n)\nresults = simulation.results\nout.append(\n{\n\"eff_pct\": efficiency_pct,\n\"charge_mwh\": results[\"battery-electric_charge_mwh\"].sum(),\n\"discharge_mwh\": results[\"battery-electric_discharge_mwh\"].sum(),\n\"loss_mwh\": results[\"battery-electric_loss_mwh\"].sum(),\n\"prices_$_mwh\": results[\"site-electricity_prices\"].mean(),\n\"import_mwh\": results[\"site-import_power_mwh\"].sum(),\n\"objective\": (results[\"site-import_power_mwh\"] - results[\"site-export_power_mwh\"] * results[\"site-electricity_prices\"]).sum(),\n}\n)\nprint(pd.DataFrame(out))\n</code></pre> <pre><code>   eff_pct  charge_mwh  discharge_mwh  loss_mwh  prices_$_mwh  import_mwh    objective\n0      1.0   18.000000           18.0  0.000000    103.197695   18.000000 -3018.344310\n1      0.9   19.111111           17.2  1.911111    103.197695   19.111111 -2893.086854\n2      0.8   20.000000           16.0  4.000000    103.197695   20.000000 -2719.962419\n</code></pre> <p>From the above we observe the following as efficiency decreases:</p> <ul> <li>an increase in battery losses,</li> <li>a reduction in the amount charged and discharged,</li> <li>a increase in the objective function, which represents an increase in cost or decrease in value of the battery arbitrage.</li> </ul>"},{"location":"validation/battery/#state-of-charge-power-ratings","title":"State of Charge &amp; Power Ratings","text":"<p>We can demonstrate the state of charge and battery power settings by first optimizing a battery and showing it's plot:</p> <pre><code>import numpy as np\nimport energypylinear as epl\nnp.random.seed(42)\nelectricity_prices = np.random.normal(100, 10, 10).tolist()\nasset = epl.Battery(power_mw=2, capacity_mwh=4, electricity_prices=electricity_prices)\nresults = asset.optimize()\nasset.plot(results, path=\"./docs/docs/static/battery.png\")\n</code></pre> <p></p> <p>Takeaways:</p> <ul> <li>the battery state of charge is constrained between 0 and 4 MWh,</li> <li>the battery power rating is constrained between -2 and 2 MW,</li> <li>battery SOC starts empty and ends empty.</li> </ul> <pre><code>import numpy as np\nimport energypylinear as epl\nnp.random.seed(42)\nasset = epl.Battery(\npower_mw=4,\ncapacity_mwh=8,\nelectricity_prices=np.random.normal(100, 10, 10),\ninitial_charge_mwh=1.0,\nfinal_charge_mwh=3.0\n)\nresults = asset.optimize()\nasset.plot(results, path=\"./docs/docs/static/battery-fast.png\")\n</code></pre> <p></p> <p>Takeaways:</p> <ul> <li>battery SOC starts at 1 MWh and ends at 3 MWh.</li> </ul>"},{"location":"validation/evs/","title":"Electric Vehicles","text":"<p>A natural response when you get access to something someone else built is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the EV asset.</p>"},{"location":"validation/evs/#fully-constrained-ev-charging","title":"Fully Constrained EV Charging","text":"<pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0,\nelectricity_prices=[-100, 50, 30, 10, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 0, 0, 0],\n[0, 0, 1, 0, 0],\n]\n)\nsimulation = asset.optimize()\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-1.png\")\n</code></pre> <p>The third charger is the spill charger.</p> <p></p>"},{"location":"validation/evs/#expanding-a-charge-event-window","title":"Expanding a Charge Event Window","text":"<p>Let's expand out the charge event window to the last three intervals for the last charge event:</p> <pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0,\nelectricity_prices=[-100, 50, 300, 10, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 0, 0, 0],\n[0, 0, 1, 1, 1],\n]\n)\nsimulation = asset.optimize()\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-2.png\")\n</code></pre> <p>Now we see that the charge has happened in interval 3, this is because electricity prices are lowest in this interval.</p> <p></p>"},{"location":"validation/evs/#overlapping-charge-events","title":"Overlapping Charge Events","text":"<p>When charge events overlap at low prices, both (but only two) chargers are used:</p> <pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0,\nelectricity_prices=[-100, 50, 300, 10, 40],\ncharge_events=[\n[1, 0, 0, 1, 0],\n[0, 1, 1, 1, 1],\n[0, 0, 1, 1, 1],\n]\n)\nsimulation = asset.optimize()\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-3.png\")\n</code></pre> <p></p>"},{"location":"validation/evs/#adding-v2g","title":"Adding V2G","text":"<pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0,\nelectricity_prices=[-100, 50, 300, 10, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 1],\n[0, 0, 1, 1, 1],\n],\n)\nsimulation = asset.optimize(\nflags=epl.Flags(allow_evs_discharge=True)\n)\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-4.png\")\n</code></pre> <p>The key takeaway here is that we discharge during interval 2.  All our charge events still end up at the correct state of charge at the end of the program.</p>"},{"location":"validation/evs/#spill-chargers","title":"Spill Chargers","text":"<pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30, 500],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0,\nelectricity_prices=[-100, 50, 300, 10, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 1],\n[0, 0, 1, 1, 1],\n[1, 0, 0, 0, 0],\n],\n)\nsimulation = asset.optimize(\nflags=epl.Flags(allow_evs_discharge=True)\n)\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-5.png\")\n</code></pre> <p>Key takeaway here is the use of the spill charger - we have a 500 MWh charge event, but only 200 MWh of capacity.  We meet the remaining demand from a spill charger.</p> <p>This allows the linear program to be feasible, while communicating directly which intervals or charge events are causing the mismatch between charge event demand and spill charger capacity.</p> <p></p>"},{"location":"validation/heat-pump/","title":"Heat Pump","text":"<p>A natural response when you get access to something someone else built is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the heat pump asset.</p>"},{"location":"validation/heat-pump/#price-dispatch-behaviour","title":"Price Dispatch Behaviour","text":"<p>Let's optimize the heat pump in two intervals - the first with a high electricity price of <code>100</code> and the second with a low  electricity price of <code>-100</code>.</p> <p>Our expectation is that the heat pump will not operate in the first interval, but will operate in the second interval:</p> <pre><code>import pandas as pd\nimport energypylinear as epl\npd.set_option(\"display.max_columns\", 4)\npd.set_option('display.width', 1000)\nasset = epl.HeatPump(\nelectric_power_mw=1.0,\ncop=2,\ngas_prices=20,\nelectricity_prices=[100, -100],\nhigh_temperature_load_mwh=3.0,\nlow_temperature_generation_mwh=4.0,\n)\nsimulation = asset.optimize(verbose=False)\nprint(simulation.results[\n[\n\"site-electricity_prices\",\n\"heat-pump-electric_load_mwh\",\n\"boiler-high_temperature_generation_mwh\"\n]\n])\n</code></pre> <pre><code>   site-electricity_prices  heat-pump-electric_load_mwh  boiler-high_temperature_generation_mwh\n0                      100                          0.0                                     3.0\n1                     -100                          1.0                                     1.0\n</code></pre> <p>For the first interval, with an electricity price of <code>100</code>, we see that:</p> <ul> <li>our heat pump has not operated (<code>heat-pump-electric_load_mwh=0</code>),</li> <li>our <code>3.0 MWh</code> of high temperature heat demand has been generated by the gas boiler.</li> </ul> <p>For the second interval, with an electricity price of <code>-100</code>, we see that:</p> <ul> <li>our heat pump is operating at <code>1.0 MWe</code>, which means we expect <code>2.0 MWh</code> of high temperature heat,</li> <li>only <code>1.0 MWh</code> of high temperature heat demand has been generated by the gas boiler.</li> </ul>"},{"location":"validation/heat-pump/#heat-balance-behaviour","title":"Heat Balance Behaviour","text":""},{"location":"validation/heat-pump/#without-a-valve","title":"Without a Valve","text":"<p>Let's first optimize a heat pump without a high temperature to low temperature valve, which stops heat from flowing from high to low temperature.</p> <p>We use a negative electricity price of <code>-100</code> for each interval, to force the heat pump to operate.</p> <pre><code>import energypylinear as epl\nasset = epl.HeatPump(\nelectric_power_mw=1.0,\ncop=2,\ngas_prices=20,\nelectricity_prices=[-100, -100, -100],\nhigh_temperature_load_mwh=[3.0, 0.5, 3.0],\nlow_temperature_generation_mwh=[4.0, 4.0, 0.5],\ninclude_valve=False\n)\nsimulation = asset.optimize(\nverbose=False,\n)\nprint(simulation.results[\n[\n\"site-high_temperature_load_mwh\",\n\"site-low_temperature_generation_mwh\",\n\"spill-low_temperature_load_mwh\",\n\"heat-pump-electric_load_mwh\",\n\"heat-pump-high_temperature_generation_mwh\",\n\"boiler-high_temperature_generation_mwh\"\n]\n])\n</code></pre> <pre><code>   site-high_temperature_load_mwh  site-low_temperature_generation_mwh  spill-low_temperature_load_mwh  heat-pump-electric_load_mwh  heat-pump-high_temperature_generation_mwh  boiler-high_temperature_generation_mwh\n0                             3.0                                  4.0                            3.00                         1.00                                        2.0                                     1.0\n1                             0.5                                  4.0                            3.75                         0.25                                        0.5                                     0.0\n2                             3.0                                  0.5                            0.00                         0.50                                        1.0                                     2.0\n</code></pre> <p>In the first interval we are unconstrained in terms of heat - our heat pump runs at the full <code>1.0 MWe</code> load.</p> <p>In the second interval we have a limited amount of high temperature heat load in the site, which constrains the heat pump.</p> <p>In the third interval we have a limited amount of low temperature heat generation in the site, which again constrains how much the heat pump can run.</p>"},{"location":"validation/heat-pump/#with-a-valve","title":"With a Valve","text":"<p>Lets now optimize a heat pump with a high temperature to low temperature valve.</p> <p>This allows heat to flow from high to low temperature, which means our boiler can generate high temperature heat that ends up as low temperature heat input into the heat pump.</p> <p>This is a pretty bizarre situation, that is optimal because of our negative electricity price.</p> <pre><code>import energypylinear as epl\nasset = epl.HeatPump(\nelectric_power_mw=1.0,\ncop=2,\ngas_prices=20,\nelectricity_prices=[-100, -100, -100],\nhigh_temperature_load_mwh=[3.0, 0.5, 3.0],\nlow_temperature_generation_mwh=[4.0, 4.0, 0.0],\ninclude_valve=True\n)\nsimulation = asset.optimize(\nverbose=False,\n)\nprint(simulation.results[\n[\n\"site-high_temperature_load_mwh\",\n\"site-low_temperature_generation_mwh\",\n\"spill-low_temperature_load_mwh\",\n\"heat-pump-electric_load_mwh\",\n\"heat-pump-high_temperature_generation_mwh\",\n\"boiler-high_temperature_generation_mwh\"\n]\n])\n</code></pre> <pre><code>   site-high_temperature_load_mwh  site-low_temperature_generation_mwh  spill-low_temperature_load_mwh  heat-pump-electric_load_mwh  heat-pump-high_temperature_generation_mwh  boiler-high_temperature_generation_mwh\n0                             3.0                                  4.0                             3.0                          1.0                                        2.0                                     1.0\n1                             0.5                                  4.0                             4.5                          1.0                                        2.0                                     0.0\n2                             3.0                                  0.0                             0.0                          1.0                                        2.0                                     2.0\n</code></pre> <p>We now see that our heat pump operates for all three intervals.  It is no longer starved for low temperature heat input, as the boiler can generate this heat.</p>"},{"location":"validation/renewable-generator/","title":"Renewable Generator","text":"<p>A natural response when you get access to something someone else built is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the renewable generator asset.</p>"},{"location":"validation/renewable-generator/#carbon-dispatch-behaviour","title":"Carbon Dispatch Behaviour","text":"<p>Let's optimize the renewable generator asset in two intervals:</p> <ol> <li>a positive import electricity carbon intensity of <code>1.0 tC/MWh</code>,</li> <li>a negative import electricity carbon intensity of <code>-0.5 tC/MWh</code>.</li> </ol> <p>If we optimize our <code>epl.RenewableGenerator</code> asset with a lower bound on the electricity generation of <code>1.0</code>, we generate the full <code>100 MW</code> in each interval:</p> <pre><code>import energypylinear as epl\nelectricity_carbon_intensities = [1.0, -0.5]\nelectric_generation_mwh=[100, 100]\nelectric_generation_lower_bound_pct=1.0\nasset = epl.RenewableGenerator(\nelectricity_carbon_intensities=electricity_carbon_intensities,\nelectric_generation_mwh=electric_generation_mwh,\nname=\"wind\",\nelectric_generation_lower_bound_pct=electric_generation_lower_bound_pct\n)\nsimulation = asset.optimize(objective=\"carbon\", verbose=False)\nprint(simulation.results[\n[\n\"site-electricity_carbon_intensities\",\n\"site-export_power_mwh\",\n\"wind-electric_generation_mwh\",\n]\n])\n</code></pre> <pre><code>   site-electricity_carbon_intensities  site-export_power_mwh  wind-electric_generation_mwh\n0                                  1.0                  100.0                         100.0\n1                                 -0.5                  100.0                         100.0\n</code></pre> <p>If we change our lower bound to <code>0.5</code>, our renewable generator asset will generate less electricity during the second, negative carbon intensity interval:</p> <pre><code>import energypylinear as epl\nelectricity_carbon_intensities = [1.0, -0.5]\nelectric_generation_mwh=[100, 100]\nelectric_generation_lower_bound_pct=0.5\nasset = epl.RenewableGenerator(\nelectricity_carbon_intensities=electricity_carbon_intensities,\nelectric_generation_mwh=electric_generation_mwh,\nname=\"wind\",\nelectric_generation_lower_bound_pct=electric_generation_lower_bound_pct\n)\nsimulation = asset.optimize(objective=\"carbon\", verbose=False)\nprint(simulation.results[\n[\n\"site-electricity_carbon_intensities\",\n\"site-export_power_mwh\",\n\"wind-electric_generation_mwh\",\n]\n])\n</code></pre> <pre><code>   site-electricity_carbon_intensities  site-export_power_mwh  wind-electric_generation_mwh\n0                                  1.0                  100.0                         100.0\n1                                 -0.5                   50.0                          50.0\n</code></pre>"}]}