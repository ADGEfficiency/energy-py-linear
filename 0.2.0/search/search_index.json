{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"energy-py-linear","text":"<p>A Python library for optimizing energy assets with mixed-integer linear programming:</p> <ul> <li>electric batteries,</li> <li>combined heat &amp; power (CHP) generators,</li> <li>electric vehicle smart charging.</li> </ul> <p>Assets can be optimized to either maximize profit or minimize carbon emissions.  </p> <p>Energy balances are performed on electricity, high &amp; low temperature heat.</p>"},{"location":"#setup","title":"Setup","text":"<p>Requires Python 3.10+:</p> <pre><code>$ pip install energypylinear\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#asset-api","title":"Asset API","text":"<p>The asset API allows optimizing a single asset at once.</p> <p>We can optimize an electric battery operating in wholesale price arbitrage using <code>epl.Battery</code>:</p> <pre><code>import energypylinear as epl\n#  2.0 MW, 4.0 MWh battery\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4, efficiency=0.9)\nresults = asset.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100]\n)\n</code></pre> <p>See how to optimize other asset types in how-to/optimize-assets. </p>"},{"location":"#site-api","title":"Site API","text":"<p>The site API allows optimizing multiple assets at once:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(assets=[\n#  2.0 MW, 4.0 MWh battery\nepl.Battery(power_mw=2.0, capacity_mwh=4.0),\n#  30 MW generator\nepl.Generator(\nelectric_power_max_mw=100,\nelectric_power_min_mw=30,\nelectric_efficiency_pct=0.4\n),\n#  2 EV chargers &amp; 4 charge events\nepl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 0],\n[0, 0, 0, 1, 1],\n[0, 1, 0, 0, 0]\n]\n)\n])\nresults = site.optimize(\nelectricity_prices=[100, 50, 200, -100, 0],\nhigh_temperature_load_mwh=[105, 110, 120, 110, 105],\nlow_temperature_load_mwh=[105, 110, 120, 110, 105]\n)\n</code></pre> <p>The site API will optimize the assets together, and return the results for each asset.</p>"},{"location":"getting-started/","title":"hi","text":""},{"location":"performance/","title":"Performance","text":""},{"location":"performance/#battery-performance","title":"Battery Performance","text":""},{"location":"performance/#ev-performance","title":"EV Performance","text":""},{"location":"how-to/dispatch-assets/","title":"Optimizing an Asset with the Asset API","text":"<p>The asset API allows optimizing a single asset at once.  Internally the assets are using the <code>epl.Site</code>, but this is hidden when using the asset API.</p> <p>You can find full examples for each asset here.</p>"},{"location":"how-to/dispatch-assets/#battery","title":"Battery","text":"<p>Dispatch an electric battery operating in wholesale price arbitrage using <code>epl.Battery</code>:</p> <pre><code>import energypylinear as epl\n#  2.0 MW, 4.0 MWh battery\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4, efficiency=0.9)\nresults = asset.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3,\nobjective=\"price\"\n)\nassert all(\nresults.simulation.columns\n== [\n'site-import_power_mwh',\n'site-export_power_mwh',\n'spill-electric_generation_mwh',\n'spill-electric_load_mwh',\n'spill-high_temperature_generation_mwh',\n'spill-low_temperature_generation_mwh',\n'spill-high_temperature_load_mwh',\n'spill-low_temperature_load_mwh',\n'spill-gas_consumption_mwh',\n'battery-electric_charge_mwh',\n'battery-electric_charge_binary',\n'battery-electric_discharge_mwh',\n'battery-electric_discharge_binary',\n'battery-electric_loss_mwh',\n'battery-initial_charge_mwh',\n'battery-final_charge_mwh',\n'electricity_prices',\n'electricity_carbon_intensities',\n'total-electric_generation_mwh',\n'total-electric_load_mwh',\n'total-high_temperature_generation_mwh',\n'total-low_temperature_generation_mwh',\n'total-high_temperature_load_mwh',\n'total-low_temperature_load_mwh',\n'total-gas_consumption_mwh',\n'total-electric_charge_mwh',\n'total-electric_discharge_mwh',\n'total-spills_mwh',\n'total-electric_loss_mwh',\n'site-electricity_balance_mwh',\n'load-high_temperature_load_mwh',\n'load-low_temperature_load_mwh'\n]\n)\n</code></pre> <p>The battery will charge with electricity at low prices, and discharge at high prices.  An efficiency penalty is applied to the battery charge energy (energy is lost during charging).</p>"},{"location":"how-to/dispatch-assets/#generator","title":"Generator","text":"<p>Dispatch a CHP (combined heat &amp; power) generator to generate electricity, high &amp; low temperature heat from natural gas.</p> <p>The <code>epl.Generator</code> model can be configured with electric, high and low temperature thermal efficiencies. </p> <p>This allows modelling both gas engines and gas turbines.</p> <p>When optimizing, we can use interval data for the high and low temperature loads.  These thermal loads will be met by gas boilers if the CHP chooses not to generate, or cannot meet thermal demands.  High temperature heat can be let-down into low temperature heat.</p> <p>The <code>epl.Generator</code> is allowed to dump both high temperature and low temperature heat.</p> <p>The high and low temperature heat demands are supplied alongside the electricity prices when optimizing:</p> <pre><code>import energypylinear as epl\n#  100 MWe gas turbine\nasset = epl.chp.Generator(\nelectric_power_max_mw=100,\nelectric_power_min_mw=50,\nelectric_efficiency_pct=0.3,\nhigh_temperature_efficiency_pct=0.5,\n)\n#  100 MWe gas engine\nasset = epl.chp.Generator(\nelectric_power_max_mw=100,\nelectric_power_min_mw=10,\nelectric_efficiency_pct=0.4,\nhigh_temperature_efficiency_pct=0.2,\nlow_temperature_efficiency_pct=0.2,\n)\nresults = asset.optimize(\nelectricity_prices=[100, 50, 200, -100, 0, 200, 100, -100],\nhigh_temperature_load_mwh=[100, 50, 200, 40, 0, 200, 100, 100],\nlow_temperature_load_mwh=20\n)\nassert all(\nresults.simulation.columns == [\n'site-import_power_mwh',\n'site-export_power_mwh',\n'spill-electric_generation_mwh',\n'spill-electric_load_mwh',\n'spill-high_temperature_generation_mwh',\n'spill-low_temperature_generation_mwh',\n'spill-high_temperature_load_mwh',\n'spill-low_temperature_load_mwh',\n'spill-gas_consumption_mwh',\n'generator-electric_generation_mwh',\n'generator-gas_consumption_mwh',\n'generator-high_temperature_generation_mwh',\n'generator-low_temperature_generation_mwh',\n'boiler-high_temperature_generation_mwh',\n'boiler-gas_consumption_mwh',\n'valve-high_temperature_load_mwh',\n'valve-low_temperature_generation_mwh',\n'electricity_prices',\n'electricity_carbon_intensities',\n'total-electric_generation_mwh',\n'total-electric_load_mwh',\n'total-high_temperature_generation_mwh',\n'total-low_temperature_generation_mwh',\n'total-high_temperature_load_mwh',\n'total-low_temperature_load_mwh',\n'total-gas_consumption_mwh',\n'total-electric_charge_mwh',\n'total-electric_discharge_mwh',\n'total-spills_mwh',\n'total-electric_loss_mwh',\n'site-electricity_balance_mwh',\n'load-high_temperature_load_mwh',\n'load-low_temperature_load_mwh'\n]\n)\n</code></pre>"},{"location":"how-to/dispatch-assets/#electric-vehicle-charging","title":"Electric Vehicle Charging","text":"<p>Control a number of EV chargers to charge a number of charge events.  </p> <p>Chargers are configured by their size given in <code>charger_mws</code>.  </p> <p>A <code>charge_event</code> is a time interval where an EV can be charged.  This is given as a boolean 2D array, with one binary digit for each charge events, interval pairs.</p> <p>Each charge event has a required amount of electricity <code>charge_event_mwh</code>, that can be delivered when the <code>charge_event</code> is 1.  The model is constrained so that each charge event receives all of it's <code>charge_event_mwh</code>.</p> <p>To optimize two 100 MWe chargers for 4 charge events over 5 intervals:</p> <pre><code>import energypylinear as epl\n#  2 100 MW EV chargers\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh = [50, 100, 30, 40],\ncharger_turndown=0.1\n)\nelectricity_prices = [-100, 50, 30, 50, 40]\ncharge_events = [\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 0],\n[0, 0, 0, 1, 1],\n[0, 1, 0, 0, 0],\n]\nresults = asset.optimize(\nelectricity_prices=electricity_prices,\ncharge_events=charge_events,\n)\nassert all(\nresults.simulation.columns == [\n'site-import_power_mwh',\n'site-export_power_mwh',\n'spill-electric_generation_mwh',\n'spill-electric_load_mwh',\n'spill-high_temperature_generation_mwh',\n'spill-low_temperature_generation_mwh',\n'spill-high_temperature_load_mwh',\n'spill-low_temperature_load_mwh',\n'spill-gas_consumption_mwh',\n'evs-charger-0-electric_charge_mwh',\n'evs-charger-0-electric_charge_binary',\n'evs-charger-0-electric_discharge_mwh',\n'evs-charger-0-electric_discharge_binary',\n'evs-charger-1-electric_charge_mwh',\n'evs-charger-1-electric_charge_binary',\n'evs-charger-1-electric_discharge_mwh',\n'evs-charger-1-electric_discharge_binary',\n'evs-charge-event-0-electric_charge_mwh',\n'evs-charge-event-0-electric_discharge_mwh',\n'evs-charge-event-0-electric_loss_mwh',\n'evs-charge-event-1-electric_charge_mwh',\n'evs-charge-event-1-electric_discharge_mwh',\n'evs-charge-event-1-electric_loss_mwh',\n'evs-charge-event-2-electric_charge_mwh',\n'evs-charge-event-2-electric_discharge_mwh',\n'evs-charge-event-2-electric_loss_mwh',\n'evs-charge-event-3-electric_charge_mwh',\n'evs-charge-event-3-electric_discharge_mwh',\n'evs-charge-event-3-electric_loss_mwh',\n'evs-charge-event-0-initial_soc_mwh',\n'evs-charge-event-1-initial_soc_mwh',\n'evs-charge-event-2-initial_soc_mwh',\n'evs-charge-event-3-initial_soc_mwh',\n'evs-charge-event-0-final_soc_mwh',\n'evs-charge-event-1-final_soc_mwh',\n'evs-charge-event-2-final_soc_mwh',\n'evs-charge-event-3-final_soc_mwh',\n'evs-charger-spill-evs-electric_charge_mwh',\n'evs-charger-spill-evs-electric_charge_binary',\n'evs-charger-spill-evs-electric_discharge_mwh',\n'evs-charger-spill-evs-electric_discharge_binary',\n'electricity_prices',\n'electricity_carbon_intensities',\n'total-electric_generation_mwh',\n'total-electric_load_mwh',\n'total-high_temperature_generation_mwh',\n'total-low_temperature_generation_mwh',\n'total-high_temperature_load_mwh',\n'total-low_temperature_load_mwh',\n'total-gas_consumption_mwh',\n'total-electric_charge_mwh',\n'total-electric_discharge_mwh',\n'total-spills_mwh',\n'total-electric_loss_mwh',\n'site-electricity_balance_mwh',\n'load-high_temperature_load_mwh',\n'load-low_temperature_load_mwh'\n]\n)\n</code></pre>"},{"location":"how-to/dispatch-forecast/","title":"Optimize for a Forecast","text":"<p><code>energypylinear</code> has the ability to optimize for both actuals &amp; forecasts.</p> <p>An asset (or site) can be used to model the variance between optimizing for actual &amp; forecast prices.</p>"},{"location":"how-to/dispatch-forecast/#setup-battery-asset","title":"Setup Battery Asset","text":"<pre><code>import energypylinear as epl\n#  interval data\nelectricity_prices = [100, 50, 200, -100, 0, 200, 100, -100]\nforecasts = [-100, 0, 200, 100, -100, 100, 50, 200]\n#  battery asset\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4, efficiency=0.9)\n</code></pre>"},{"location":"how-to/dispatch-forecast/#optimize-with-perfect-foresight","title":"Optimize with Perfect Foresight","text":"<pre><code>#  optimize with perfect foresight\nactual = asset.optimize(electricity_prices=electricity_prices, verbose=False)\n# create accounts for the two scenarios \nperfect_foresight = epl.get_accounts(actual.interval_data, actual.simulation, verbose=False)\nprint(f\"{perfect_foresight=}\")\n</code></pre> <pre><code>perfect_foresight=&lt;Accounts profit=1057.78 emissions=0.0822&gt;\n</code></pre>"},{"location":"how-to/dispatch-forecast/#optimize-to-a-forecast","title":"Optimize to a Forecast","text":"<pre><code>#  optimize to the forecast\nforecast = asset.optimize(electricity_prices=forecasts, verbose=False)\n# in the forecast we use the actual interval_data, not the forecast interval_data\nforecast_account = epl.get_accounts(actual.interval_data, forecast.simulation, verbose=False)\nprint(f\"{forecast_account=}\")\n</code></pre> <pre><code>forecast_account=&lt;Accounts profit=-140.00 emissions=0.0800&gt;\n</code></pre>"},{"location":"how-to/dispatch-forecast/#calculate-variance-between-accounts","title":"Calculate Variance Between Accounts","text":"<pre><code>variance = perfect_foresight - forecast_account\nprint(f\"{variance=}\")\n</code></pre> <pre><code>variance=&lt;Account profit=1197.78 emissions=0.0022&gt;\n</code></pre> <p>See examples/forecast-accuracy.py for a complete example.</p>"},{"location":"how-to/dispatch-site/","title":"Multiple Assets with the Site API","text":"<p>The site API allows optimizing many assets at the same time.</p> <p>Multiple assets can be optimized using a single <code>epl.Site</code>, which accepts a list of assets.</p> <p>Below we give some examples of typical configurations of energy assets.</p>"},{"location":"how-to/dispatch-site/#battery-chp-generator","title":"Battery &amp; CHP Generator","text":"<p>We can use a site to optimize an electric battery alongside a gas fired generator:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(assets=[\nepl.Battery(power_mw=2.0, capacity_mwh=4.0),\nepl.Generator(\nelectric_power_max_mw=100,\nelectric_power_min_mw=30,\nelectric_efficiency_pct=0.4\n)\n])\nresults = site.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3\n)\n</code></pre>"},{"location":"how-to/dispatch-site/#fast-slow-battery","title":"Fast &amp; Slow Battery","text":"<p>We can use a site to optimize a fast and slow battery alongside each other:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(assets=[\nepl.Battery(power_mw=4.0, capacity_mwh=1.0),\nepl.Battery(power_mw=2.0, capacity_mwh=4.0),\n])\nresults = site.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3\n)\n</code></pre>"},{"location":"how-to/dispatch-site/#battery-ev-chargers","title":"Battery &amp; EV Chargers","text":"<p>We can use a site to optimize a battery that sits alongside EV chargers:</p> <pre><code>import energypylinear as epl\nsite = epl.Site(assets=[\nepl.Battery(power_mw=2.0, capacity_mwh=4.0),\nepl.EVs(charger_mws=[100, 100], charger_turndown=0.1)\n])\nresults = site.optimize(\nelectricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\nfreq_mins=60,\ninitial_charge_mwh=1,\nfinal_charge_mwh=3,\ncharge_events=[\n[1, 0, 0, 0, 0, 0, 0, 0],\n[0, 1, 1, 1, 0, 0, 0, 0],\n[0, 0, 0, 1, 1, 0, 0, 0],\n[0, 1, 0, 0, 0, 0, 0, 0],\n],\ncharge_event_mwh=[50, 100, 30, 40]\n)\n</code></pre>"},{"location":"how-to/price-carbon/","title":"Optimize for Carbon","text":"<p><code>energypylinear</code> has the ability to optimize for both price and carbon as optimization objectives.</p> <p>This ability comes from two things - an objective function, which can be either for price or carbon, along with accounting of both price and carbon emissions.</p> <p>We can dispatch a battery to minimize carbon emissions by passing in <code>objective='carbon'</code>:</p>"},{"location":"how-to/price-carbon/#setup-battery-asset","title":"Setup Battery Asset","text":"<pre><code>import energypylinear as epl\n#  interval data\nelectricity_prices = [100, 50, 200, -100, 0, 200, 100, -100]\nelectricity_carbon_intensities = [0.1, 0.2, 0.1, 0.15, 0.01, 0.7, 0.5, 0.01]\n#  battery asset\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4, efficiency=0.9)\n</code></pre>"},{"location":"how-to/price-carbon/#optimize-for-carbon","title":"Optimize for Carbon","text":"<pre><code>#  optimize for carbon\ncarbon = asset.optimize(\nelectricity_prices=electricity_prices,\nelectricity_carbon_intensities=electricity_carbon_intensities,\nobjective='carbon',\nverbose=False\n)\ncarbon_account = epl.get_accounts(\ncarbon.interval_data,\ncarbon.simulation,\nverbose=False\n)\nprint(f\"{carbon_account=}\")\n</code></pre> <pre><code>carbon_account=&lt;Accounts profit=134.44 emissions=-2.2733&gt;\n</code></pre>"},{"location":"how-to/price-carbon/#optimize-for-money","title":"Optimize for Money","text":"<p>We can compare these results above with a simulation that optimizes for price, using a <code>energypylinear.accounting.Account</code> to compare both simulations.  </p> <p>Our optimization for price has a high negative cost.  </p> <p>The optimization for carbon has lower emissions, but at a higher cost:</p> <pre><code>#  optimize for money\nprice = asset.optimize(\nelectricity_prices=electricity_prices,\nverbose=False\n)\n#  get an account representing the difference between the two\nprice_account = epl.get_accounts(\nprice.interval_data,\nprice.simulation,\nverbose=False\n)\nprint(f\"{price_account=}\")\n</code></pre> <pre><code>price_account=&lt;Accounts profit=1057.78 emissions=0.0822&gt;\n</code></pre>"},{"location":"how-to/price-carbon/#calculate-variance-between-accounts","title":"Calculate Variance Between Accounts","text":"<pre><code>variance = price_account - carbon_account\nprint(f\"{variance=}\")\nprint(f\"{-variance.cost / variance.emissions:.2f} $/tC\")\n</code></pre> <pre><code>variance=&lt;Account profit=923.33 emissions=2.3556&gt;\n391.98 $/tC\n</code></pre>"},{"location":"validation/battery/","title":"Battery","text":"<p>A natural response when you get access to something someone else build is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the battery implementation.</p>"},{"location":"validation/battery/#price-dispatch-behaviour","title":"Price Dispatch Behaviour","text":"<p>Let's optimize a battery using a sequence of five prices.</p> <p>We expect that the battery will charge when prices are low, and will discharge when prices are high.</p> <p>In <code>energypylinear</code>, a positive site electricity balance is importing, and a negative site electricity balance is exporting.</p> <pre><code>import energypylinear as epl\nasset = epl.Battery()\nresults = asset.optimize(\nelectricity_prices=[10, -50, 200, -50, 200],\nverbose=False\n)\nprint(results.simulation[\n[\"electricity_prices\", \"site-electricity_balance_mwh\"]\n])\n</code></pre> <pre><code>   electricity_prices  site-electricity_balance_mwh\n0                  10                      0.444444\n1                 -50                      2.000000\n2                 200                     -2.000000\n3                 -50                      2.000000\n4                 200                     -2.000000\n</code></pre> <p>As expected, the battery charges (with a site that is positive) when prices are low and discharges (with a negative site electricity balance) when prices are high.</p> <p>Now let's change the prices and see how the dispatch changes:</p> <pre><code>import energypylinear as epl\nasset = epl.Battery()\nresults = asset.optimize(\nelectricity_prices=[200, -50, -50, 200, 200],\nverbose=False\n)\nprint(results.simulation[\n[\"electricity_prices\", \"site-electricity_balance_mwh\"]\n])\n</code></pre> <pre><code>   electricity_prices  site-electricity_balance_mwh\n0                 200                           0.0\n1                 -50                           2.0\n2                 -50                           2.0\n3                 200                          -2.0\n4                 200                          -1.6\n</code></pre> <p>As expected, the battery continues to charge during low electricity price intervals, and discharge when electricity prices are high.</p>"},{"location":"validation/battery/#energy-balance","title":"Energy Balance","text":"<p>Let's return to our original set of prices and check the energy balance of the battery:</p> <pre><code>import pandas as pd\nimport energypylinear as epl\npd.set_option('display.max_columns', 15)\npd.set_option('display.width', 400)\nasset = epl.Battery()\nresults = asset.optimize(\nelectricity_prices=[10, -50, 200, -50, 200],\nverbose=False\n)\nbalance = epl.results.checks.check_electricity_balance(results.simulation, verbose=False)\nprint(balance)\n</code></pre> <pre><code>      input  accumulation  output  raw_balance  balance    import  generation  export  load    charge  discharge      loss  spills  soc\n0  0.444444     -0.444444     0.0         True     True  0.444444         0.0     0.0   0.0  0.444444        0.0  0.044444     0.0  0.0\n1  2.000000     -2.000000     0.0         True     True  2.000000         0.0     0.0   0.0  2.000000        0.0  0.200000     0.0  0.0\n2  0.000000      2.000000     2.0         True     True  0.000000         0.0     2.0   0.0  0.000000        2.0  0.000000     0.0  0.0\n3  2.000000     -2.000000     0.0         True     True  2.000000         0.0     0.0   0.0  2.000000        0.0  0.200000     0.0  0.0\n4  0.000000      2.000000     2.0         True     True  0.000000         0.0     2.0   0.0  0.000000        2.0  0.000000     0.0  0.0\n</code></pre> <p>In the first interval, we charge the battery with <code>0.444444 MWh</code> - <code>0.4 MWh</code> goes into increasing the battery state of charge from <code>0.0 MWh</code> to <code>0.4 MWh</code>, with the balance <code>0.044444 MWh</code> going to battery losses.</p>"},{"location":"validation/battery/#battery-efficiency","title":"Battery Efficiency","text":"<p>We can validate the performance of the battery efficiency by checking the losses across different battery efficiencies:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport energypylinear as epl\nnp.random.seed(42)\nprices = (np.random.uniform(-100, 100, 12) + 100).tolist()\nout = []\nfor efficiency_pct in [1.0, 0.9, 0.8]:\nasset = epl.battery.Battery(\npower_mw=4,\ncapacity_mwh=10,\nefficiency=efficiency_pct\n)\nresults = asset.optimize(\nelectricity_prices=prices,\nobjective=\"price\",\nverbose=False\n)\nout.append(\n{\n\"eff_pct\": efficiency_pct,\n\"charge_mwh\": results.simulation[\"battery-electric_charge_mwh\"].sum(),\n\"discharge_mwh\": results.simulation[\"battery-electric_discharge_mwh\"].sum(),\n\"loss_mwh\": results.simulation[\"battery-electric_loss_mwh\"].sum(),\n\"prices_$_mwh\": results.simulation[\"electricity_prices\"].mean(),\n\"import_mwh\": results.simulation[\"site-import_power_mwh\"].sum(),\n\"objective\": (results.simulation[\"site-import_power_mwh\"] - results.simulation[\"site-export_power_mwh\"] * results.simulation[\"electricity_prices\"]).sum(),\n}\n)\nprint(pd.DataFrame(out))\n</code></pre> <pre><code>   eff_pct  charge_mwh  discharge_mwh  loss_mwh  prices_$_mwh  import_mwh    objective\n0      1.0   18.000000           18.0  0.000000    103.197695   18.000000 -3018.344310\n1      0.9   19.111111           17.2  1.911111    103.197695   19.111111 -2893.086854\n2      0.8   20.000000           16.0  4.000000    103.197695   20.000000 -2719.962419\n</code></pre> <p>From the above we observe the following as efficiency decreases:</p> <ul> <li>an increase in battery losses,</li> <li>a reduction in the amount charged and discharged,</li> <li>a increase in the objective function, which represents an increase in cost or decrease in value of the battery arbitrage.</li> </ul>"},{"location":"validation/battery/#state-of-charge-power-ratings","title":"State of Charge &amp; Power Ratings","text":"<p>We can demonstrate the state of charge and battery power settings by first optimizing a battery and showing it's plot:</p> <pre><code>import numpy as np\nimport energypylinear as epl\nnp.random.seed(42)\nelectricity_prices = np.random.normal(100, 10, 10).tolist()\nasset = epl.battery.Battery(power_mw=2, capacity_mwh=4)\nresults = asset.optimize(electricity_prices=electricity_prices)\nasset.plot(results, path=\"./docs/docs/static/battery.png\")\n</code></pre> <p></p> <p>Takeaways:</p> <ul> <li>the battery state of charge is constrained between 0 and 4 MWh,</li> <li>the battery power rating is constrained between -2 and 2 MW,</li> <li>battery SOC starts empty and ends empty.</li> </ul> <pre><code>import numpy as np\nimport energypylinear as epl\nnp.random.seed(42)\nelectricity_prices = np.random.normal(100, 10, 10).tolist()\nasset = epl.battery.Battery(\npower_mw=4,\ncapacity_mwh=8,\n)\nresults = asset.optimize(\nelectricity_prices=electricity_prices,\ninitial_charge_mwh=1.0,\nfinal_charge_mwh=3.0\n)\nasset.plot(results, path=\"./docs/docs/static/battery-fast.png\")\n</code></pre> <p></p> <p>Takeaways:</p> <ul> <li>battery SOC starts at 1 MWh and ends at 3 MWh.</li> </ul>"},{"location":"validation/evs/","title":"EVs","text":"<p>A natural response when you get access to something someone else build is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the EV implementation.</p>"},{"location":"validation/evs/#fully-constrained-ev-charging","title":"Fully Constrained EV Charging","text":"<pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0\n)\nresults = asset.optimize(\nelectricity_prices=[-100, 50, 30, 10, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 0, 0, 0],\n[0, 0, 1, 0, 0],\n]\n)\nasset.plot(results, path=\"./docs/docs/static/ev-validation-1.png\")\n</code></pre> <p>Note third charger - this is the spill charger</p> <p></p>"},{"location":"validation/evs/#expanding-a-charge-event-window","title":"Expanding a Charge Event Window","text":"<pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0\n)\nresults = asset.optimize(\nelectricity_prices=[-100, 50, 300, 10, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 0, 0, 0],\n[0, 0, 1, 1, 1],\n]\n)\nasset.plot(results, path=\"./docs/docs/static/ev-validation-2.png\")\n</code></pre> <p>Now we see that the charge has happened in interval 3, this is because electricity prices are lowest in this interval.</p> <p></p>"},{"location":"validation/evs/#overlapping-charge-events","title":"Overlapping Charge Events","text":"<pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0\n)\nresults = asset.optimize(\nelectricity_prices=[-100, 50, 300, 10, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 1],\n[0, 0, 1, 1, 1],\n]\n)\nasset.plot(results, path=\"./docs/docs/static/ev-validation-3.png\")\n</code></pre> <p>we have moved our 100 MWh charging into the third interval</p> <p>our first charge event is still at the negative price because splitting our 100 MWh load would be worse</p> <p>do the math here just as a fyi</p>"},{"location":"validation/evs/#adding-v2g","title":"Adding V2G","text":"<pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0\n)\nresults = asset.optimize(\nelectricity_prices=[-100, 50, 300, 10, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 1],\n[0, 0, 1, 1, 1],\n],\nflags=epl.Flags(allow_evs_discharge=True)\n)\nasset.plot(results, path=\"./docs/docs/static/ev-validation-4.png\")\n</code></pre> <p>The key takeaway here is that we discharge during interval 2.  All our charge events still end up at the correct state of charge at the end of the program.</p>"},{"location":"validation/evs/#spill-chargers","title":"Spill Chargers","text":"<pre><code>import energypylinear as epl\nasset = epl.EVs(\nchargers_power_mw=[100, 100],\ncharge_events_capacity_mwh=[50, 100, 30, 500],\ncharger_turndown=0.0,\ncharge_event_efficiency=1.0\n)\nresults = asset.optimize(\nelectricity_prices=[-100, 50, 300, 10, 40],\ncharge_events=[\n[1, 0, 0, 0, 0],\n[0, 1, 1, 1, 1],\n[0, 0, 1, 1, 1],\n[1, 0, 0, 0, 0],\n],\nflags=epl.Flags(allow_evs_discharge=True)\n)\nasset.plot(results, path=\"./docs/docs/static/ev-validation-5.png\")\n</code></pre> <p>Key takeaway here is the use of the spill charger - we have a 500 MWh charge event, but only 200 MWh of capacity.  We meet the remaining demand from a spill charger.</p> <p>This allows the linear program to be feasible, while communicating directly which intervals or charge events are causing the mismatch between charge event demand and spill charger capacity.</p> <p></p>"}]}