{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"energy-py-linear","text":"<p>A Python library for optimizing energy assets with mixed-integer linear programming:</p> <ul> <li>electric batteries,</li> <li>combined heat &amp; power (CHP) generators,</li> <li>electric vehicle smart charging,</li> <li>heat pumps,</li> <li>renewable (wind &amp; solar) generators.</li> </ul> <p>Assets can be optimized to either maximize profit or minimize carbon emissions, or for user defined custom objective functions. Custom constraints can be used to further constrain asset behaviour.</p> <p>A site is a collection of assets that can be optimized together. Sites can use custom objectives and constraints.</p> <p>Energy balances are performed on electricity, high, and low temperature heat.</p>"},{"location":"#setup","title":"Setup","text":"<p>Requires Python 3.11 or 3.12:</p> <pre><code>$ pip install energypylinear\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#asset-api","title":"Asset API","text":"<p>The asset API allows optimizing a single asset at once:</p> <pre><code>import energypylinear as epl\n\n#  2.0 MW, 4.0 MWh battery\nasset = epl.Battery(\n    power_mw=2,\n    capacity_mwh=4,\n    efficiency_pct=0.9,\n    # different electricity prices for each interval\n    # length of electricity_prices is the length of the simulation\n    electricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\n    # a constant value for each interval\n    export_electricity_prices=40,\n)\n\nsimulation = asset.optimize()\n</code></pre>"},{"location":"#site-api","title":"Site API","text":"<p>The site API allows optimizing multiple assets together:</p> <pre><code>import energypylinear as epl\n\nassets = [\n    #  2.0 MW, 4.0 MWh battery\n    epl.Battery(power_mw=2.0, capacity_mwh=4.0),\n    #  30 MW open cycle generator\n    epl.CHP(\n        electric_power_max_mw=100, electric_power_min_mw=30, electric_efficiency_pct=0.4\n    ),\n    #  2 EV chargers &amp; 4 charge events\n    epl.EVs(\n        chargers_power_mw=[100, 100],\n        charge_events_capacity_mwh=[50, 100, 30, 40],\n        charge_events=[\n            [1, 0, 0, 0, 0],\n            [0, 1, 1, 1, 0],\n            [0, 0, 0, 1, 1],\n            [0, 1, 0, 0, 0],\n        ],\n    ),\n    #  natural gas boiler to generate high temperature heat\n    epl.Boiler(),\n    #  valve to generate low temperature heat from high temperature heat\n    epl.Valve(),\n]\n\nsite = epl.Site(\n    assets=assets,\n    # length of energy prices is the length of the simulation\n    electricity_prices=[100, 50, 200, -100, 0],\n    # these should match the length of the export_electricity_prices\n    # if they don't, they will be repeated or cut to match the length of electricity_prices\n    high_temperature_load_mwh=[105, 110, 120, 110, 105],\n    low_temperature_load_mwh=[105, 110, 120, 110, 105],\n)\n\nsimulation = site.optimize()\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#140","title":"1.4.0","text":""},{"location":"changelog/#custom-constraints","title":"Custom Constraints","text":"<p>It's now possible to add custom constraints to the linear program.</p> <p>The example below shows how to add a constraint on battery cycles:</p> <pre><code>import energypylinear as epl\nimport numpy as np\n\nnp.random.seed(42)\ncycle_limit_mwh = 30\nasset = epl.Battery(\n    power_mw=1,\n    capacity_mwh=2,\n    efficiency_pct=0.98,\n    electricity_prices=np.random.normal(0.0, 1000, 48 * 7),\n    constraints=[\n        epl.Constraint(\n            lhs=[\n                epl.ConstraintTerm(\n                    asset_type=\"battery\", variable=\"electric_charge_mwh\"\n                ),\n                epl.ConstraintTerm(\n                    asset_type=\"battery\", variable=\"electric_discharge_mwh\"\n                ),\n            ],\n            rhs=cycle_limit,\n            sense=\"le\",\n            interval_aggregation=\"sum\",\n        )\n    ],\n)\n</code></pre> <p>Read more about custom constraints in the documentation.</p>"},{"location":"changelog/#documentation-refactor","title":"Documentation Refactor","text":"<p>We have moved the asset validation documentation into the documentation for the assets.</p> <p>A new section <code>Customization</code> has been added to the documentation, which contains the documentation for custom constraints and objective functions.</p>"},{"location":"changelog/#130","title":"1.3.0","text":""},{"location":"changelog/#different-battery-charge-and-discharge-rates","title":"Different Battery Charge and Discharge Rates","text":"<p>It's now possible to define a different charge and discharge rate in the <code>epl.Battery</code> asset.</p> <p>The example below defines a maximum charge and discharge rate of <code>2.0</code>:</p> <pre><code>epl.Battery(power_mw=2.0)\n</code></pre> <p>The example below defines a maximum charge rate of <code>2.0</code> with a maximum discharge rate of <code>1.0</code>:</p> <pre><code>epl.Battery(power_mw=2.0, discharge_power_mw=1.0)\n</code></pre>"},{"location":"changelog/#complex-objective-function-terms","title":"Complex Objective Function Terms","text":"<p>A complex custom objective term allows you to construct an objective function with a complex set of costs and revenues.</p> <p>For example, we can define an objective function that includes a cost for the maximum import above a threshold of <code>40</code>:</p> <pre><code>{\n    \"function\": \"max_many_variables\",\n    \"variables\": {\n        \"asset_type\": \"site\",\n        \"variable\": \"import_power_mwh\",\n    },\n    \"constant\": 40,\n    \"coefficient\": 200,\n    \"M\": max(electric_load_mwh) * 10\n}\n</code></pre> <p>See Complex Objective Function Terms in the documentation for more examples.</p>"},{"location":"changelog/#custom-accounts","title":"Custom Accounts","text":"<p>To accommodate complex custom objective functions, we have added the ability to include these custom costs and revenues as a custom account:</p> <pre><code>import energypylinear as epl\n\nchp_size = 50\nelectric_efficiency = 0.5\nelectric_load_mwh = 0\nelectricity_prices = np.array([-1000, -750, -250, -100, 0, 10, 100, 1000])\nexport_charge = -500\nexport_threshold_mwh = 5\ngas_prices = 20\n\nassets = [\n    epl.CHP(\n        electric_efficiency_pct=electric_efficiency,\n        electric_power_max_mw=chp_size,\n    )\n]\nsite = epl.Site(\n    assets=assets,\n    gas_prices=20,\n    electricity_prices=np.array([-1000, -750, -250, -100, 0, 10, 100, 1000]),\n    electric_load_mwh=electric_load_mwh,\n)\n\nterms: list[dict] = [\n    {\n        \"asset_type\": \"site\",\n        \"variable\": \"export_power_mwh\",\n        \"interval_data\": \"electricity_prices\",\n        \"coefficient\": -1,\n    },\n    {\n        \"asset_type\": \"*\",\n        \"variable\": \"gas_consumption_mwh\",\n        \"interval_data\": \"gas_prices\",\n    },\n    {\n        \"type\": \"complex\",\n        \"function\": \"min_two_variables\",\n        \"a\": {\n            \"asset_type\": \"site\",\n            \"variable\": \"export_power_mwh\",\n        },\n        \"b\": 5.0,\n        \"coefficient\": export_charge,\n        \"M\": (\n            electric_load_mwh\n            + assets[0].cfg.electric_power_max_mw\n            + export_threshold_mwh\n        )\n        * 1,\n    },\n]\n\nsimulation = site.optimize(\n    verbose=4,\n    objective={\"terms\": terms},\n)\n\naccounts = epl.get_accounts(simulation.results, custom_terms=terms[-1:])\nprint(accounts.custom)\n</code></pre> <pre><code>&lt;Account profit=15000.00 emissions=0.0000&gt;\n</code></pre>"},{"location":"changelog/#optimization-status","title":"Optimization Status","text":"<p>The objective function value has been added to the <code>epl.optimizer.OptimizationStatus</code> object:</p> <pre><code>import energypylinear as epl\n\nsite = epl.Site(\n    assets=[epl.Battery()],\n    electricity_prices=np.array([-1000, -750, -250, -100, 0, 10, 100, 1000]),\n)\nsimulation = site.optimize(verbose=4, objective=\"price\")\nprint(simulation.status)\n</code></pre> <pre><code>OptimizationStatus(status='Optimal', feasible=True, objective=-5811.11111)\n</code></pre>"},{"location":"changelog/#120","title":"1.2.0","text":""},{"location":"changelog/#custom-objective-functions","title":"Custom Objective Functions","text":"<p>A custom objective function allows users to create their own objective functions in the linear program.  </p> <p>This allows users to optimize for a custom set of revenues and costs. The objective function can target assets by type or name, and can include multiplication by interval data and/or a coefficient.</p> <p>The example below shows how to include a cost for battery use (a cycle cost) applied to the battery discharge:</p> <pre><code>import numpy as np\nimport energypylinear as epl\n\nassets = [\n    epl.Battery(power_mw=20, capacity_mwh=20)\n]\nsite = epl.Site(\n    assets=assets,\n    electricity_prices=np.random.normal(0, 1000, 48)\n)\nterms=[\n    {\n        \"asset_type\":\"site\",\n        \"variable\":\"import_power_mwh\",\n        \"interval_data\":\"electricity_prices\"\n    },\n    {\n        \"asset_type\":\"site\",\n        \"variable\":\"export_power_mwh\",\n        \"interval_data\":\"electricity_prices\",\n        \"coefficient\":-1\n    },\n    {\n        \"asset_type\": \"battery\",\n        \"variable\": \"electric_discharge_mwh\",\n        \"interval_data\": \"electricity_prices\",\n        \"coefficient\": 0.25\n    }\n]\nsite.optimize(objective={\"terms\": terms})\n</code></pre> <p>See Custom Objectives in the documentation for more examples.</p>"},{"location":"changelog/#logging-improvements","title":"Logging Improvements","text":"<p>The dependency on <code>structlog</code> has been removed - we now only use <code>rich.logging.Console</code> to log to STDOUT. The ability to log to a file has been removed.</p> <p>The <code>verbose</code> flag now accepts either a <code>bool</code> or an <code>int</code>. The mapping of <code>verbose</code> to log levels is as follows:</p> <code>verbose</code> Log Level True INFO False ERROR 1 DEBUG 2 INFO 3 WARNING 4 ERROR <pre><code>import energypylinear as epl\nasset = epl.Battery(electricity_prices=[10, -50, 200, -50, 200])\nsimulation = asset.optimize(verbose=2)\n</code></pre> <pre><code>INFO     assets.site.optimize: cfg=&lt;SiteConfig name=site, freq_mins=60,         \n         import_limit_mw=10000.0, export_limit_mw=10000.0&gt;                      \nINFO     assets.site.optimize: cfg=&lt;SiteConfig name=site, freq_mins=60,         \n         import_limit_mw=10000.0, export_limit_mw=10000.0&gt;                      \nINFO     assets.site.optimize: assets=['battery', 'spill']                      \nINFO     assets.site.optimize: assets=['battery', 'spill']                      \nINFO     optimizer.solve: status='Optimal'                                      \nINFO     optimizer.solve: status='Optimal'                                      \n</code></pre>"},{"location":"changelog/#tighten-optimizer-tolerance","title":"Tighten Optimizer Tolerance","text":"<p>The default relative tolerance of the CBC optimizer has been reduced to <code>0.0</code>.</p>"},{"location":"changelog/#optimizer-config-can-be-a-dictionary","title":"Optimizer Config can be a Dictionary","text":"<p>It's now possible to use a dictionary in place of the <code>epl.OptimizerConfig</code> object:</p> <pre><code>asset.optimize(optimizer_config={\"timeout\": 2, \"relative_tolerance\": 0.1})\n</code></pre>"},{"location":"changelog/#other-changes","title":"Other Changes","text":"<p>We have upgraded Poetry to 1.7.0 and Mypy to 1.7.0.</p> <p>Plausible analytics added to the documentation.</p>"},{"location":"changelog/#111","title":"1.1.1","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<p>Fixed a bug where logger was making a <code>./logs</code> directory even when <code>enable_file_logging</code> was set to false.</p> <p>Fixed the flaky test of battery export prices by reducing optimizer tolerance to 0 in the test.</p>"},{"location":"changelog/#other-changes_1","title":"Other Changes","text":"<p>Removed documentation <code>.png</code> images from <code>main</code>.</p>"},{"location":"changelog/#110","title":"1.1.0","text":""},{"location":"changelog/#export-electricity-prices","title":"Export Electricity Prices","text":"<p>Assets can now accept export electricity prices - these are an optional time series that can either be a constant value or interval data:</p> <pre><code>asset = epl.Battery(\n    electricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\n    export_electricity_prices=40\n)\n</code></pre> <p>These export electricity prices are used to calculate the value of electricity exported from site.</p>"},{"location":"changelog/#optimizer-config","title":"Optimizer Config","text":"<p>The <code>.optimize()</code> method of assets now accepts an <code>epl.OptimizerConfig</code> object, which allows configuration of the CBC optimizer used by Pulp:</p> <pre><code>asset.optimize(\n    optimizer_config=epl.OptimizerConfig(timeout=60, relative_tolerance=0.05)\n)\n</code></pre>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<p>Fixed a bug on the <code>allow_infeasible</code> flag in <code>epl.Site.optimize</code>.</p> <p>Fixed a bug on the <code>export_limit_mw</code> in <code>epl.Site.__init__</code>.</p>"},{"location":"changelog/#netting-off-battery-charge-and-discharge","title":"Netting Off Battery Charge and Discharge","text":"<p><code>energypylinear</code> has the ability to constrain battery charge or discharge into a single interval, using binary variables that are linked to the charge and discharge energy.</p> <p>By default these were turned off, because it slows down the optimization. The effect on the site electricity balance was zero, as the charge and discharge energy were netted off in the balance.</p> <p>However, as the battery losses are a percentage of battery charge, this led to situations where when electricity prices were negative, the optimizer would be incentivized to have a large simultaneous charge and discharge.  This would also lead to the situation where the losses calculations were correct as a percentage of battery charge, but not of battery net charge.</p> <p>The solution is to remove the flag that allowed toggling of these binary variables on and off - this now means that the battery model always runs with binary variables limiting only one of charge or discharge to occur in a single interval.</p>"},{"location":"changelog/#100","title":"1.0.0","text":""},{"location":"changelog/#add-renewable-generator-asset","title":"Add Renewable Generator Asset","text":"<p>The <code>epl.RenewableGenerator</code> asset models controllable renewable generation like solar or wind.</p> <pre><code>import energypylinear as epl\n\nasset = epl.RenewableGenerator(\n    electricity_prices=[1.0, -0.5],\n    electric_generation_mwh=[100, 100],\n    electric_generation_lower_bound_pct=0.5,\n    name=\"wind\",\n)\n</code></pre> <p>This asset can clip the lower bound of the generation to a percentage of the total available generation.</p> <p>This allows the renewable generator asset to reduce its generation during periods of negative prices or carbon intensities.</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/#interval-data-rework","title":"Interval Data Rework","text":"<p>v1.0.0 moves the interval data arguments to asset from <code>asset.optimize</code> to <code>asset.__init__</code>:</p> <pre><code>import energypylinear as epl\n\n#  the old way\nasset = epl.Battery()\nsimulation = asset.optimize(electricity_prices=[10, -50, 200, -50, 200])\n\n#  the new way\nasset = epl.Battery(electricity_prices=[10, -50, 200, -50, 200])\nsimulation = asset.optimize()\n</code></pre> <p>The reasons for this change is that it allows different asset specific interval data to be specified when using the <code>epl.Site</code> API.</p>"},{"location":"changelog/#other-breaking-changes","title":"Other Breaking Changes","text":"<p><code>electricity_prices</code> is now optional - only one of <code>electricity_prices</code> or <code>elelectriciy_carbon_intensities</code> must be specified during the initialization of either an asset or site.</p> <p>For the <code>epl.Battery</code> asset, the argument <code>efficiency</code> has been renamed <code>efficiency_pct</code>.</p> <p>The <code>epl.Generator</code> asset has been renamed to <code>epl.CHP</code>.</p> <p>The accounting API has been reworked:</p> <pre><code>account = epl.get_accounts(\n    forecasts.results,\n    price_results=actuals.results,\n    verbose=False\n)\n</code></pre> <p>The simulation results object has been changed - the results <code>pd.Dataframe</code> is now the <code>.results</code> attribute on the simulation result object:</p> <pre><code>#  old way\nresults = asset.optimize()\nresults = results.simulation\n\n#  new way\nsimulation = asset.optimize()\nresults = simulation.results\n</code></pre>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<p>Fixed a bug in the documentation for optimizing for price and carbon.</p> <p>Added the heat pump asset to the <code>epl.Site</code> API.</p>"},{"location":"changelog/#documentation","title":"Documentation","text":"<p>Expanded the asset documentation from a single file into separate files, one per asset. Moved examples into the asset documentation.</p> <p>Renamed the optimization section into <code>How To</code>.</p>"},{"location":"changelog/#other-changes_2","title":"Other Changes","text":"<p>Adopted semantic versioning.</p> <p>Moved changelog into docs/changelog.</p> <p>Updated versions of Pydantic, Pandas &amp; Numpy.</p>"},{"location":"changelog/#021","title":"0.2.1","text":"<p>Added the <code>epl.HeatPump</code> asset.</p>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>Added bi-directional V2G charging to the EV asset.</p>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>Added the site API, add hosted documentation.</p>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>Allowed Python 3.11.</p>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>Added <code>energypylinear</code> to PyPi.</p>"},{"location":"getting-started/","title":"hi","text":""},{"location":"performance/","title":"Performance","text":"<p>This page is in development - you shouldn't be here!</p>"},{"location":"performance/#battery","title":"Battery","text":""},{"location":"performance/#evs","title":"EVs","text":""},{"location":"assets/battery/","title":"Battery","text":"<p>The <code>epl.Battery</code> asset is suitable for modelling an electric battery, such as a lithium-ion battery.</p>"},{"location":"assets/battery/#assumptions","title":"Assumptions","text":"<p>The battery charge rate is defined by <code>power_mw</code>, which defines both the maximum rate of charge and discharge. <code>discharge_power_mw</code> can be used to define a different rate of maximum discharge. Both the charge and discharge power are independent of the battery state of charge.</p> <p>The battery storage capacity is defined by <code>capacity_mwh</code>.  This should be the capacity after taking into account any battery depth of discharge limits.</p> <p>An efficiency penalty is applied to the battery charge energy, based on the <code>efficiency_pct</code> parameter.  No electricity is lost when discharging or during storage. The efficiency is independent of the battery state of charge.</p> <p><code>initial_charge_mwh</code> and <code>final_charge_mwh</code> control the battery state of charge at the start and end of the simulation.  These can cause infeasible simulations if the battery is unable to charge or discharge enough to meet these constraints.</p>"},{"location":"assets/battery/#use","title":"Use","text":"<p>You can optimize a single battery with <code>epl.Battery</code>:</p> <pre><code>import energypylinear as epl\n\nasset = epl.Battery(\n    power_mw=2,\n    discharge_power_mw=2,\n    capacity_mwh=4,\n    efficiency_pct=0.9,\n    electricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\n    freq_mins=60,\n    initial_charge_mwh=1,\n    final_charge_mwh=3,\n    name=\"battery\",\n    include_spill=True\n)\nsimulation = asset.optimize()\n\nassert all(\n    simulation.results.columns\n    == [\n        \"site-import_power_mwh\",\n        \"site-export_power_mwh\",\n        \"site-electricity_prices\",\n        \"site-export_electricity_prices\",\n        \"site-electricity_carbon_intensities\",\n        \"site-gas_prices\",\n        \"site-electric_load_mwh\",\n        \"site-high_temperature_load_mwh\",\n        \"site-low_temperature_load_mwh\",\n        \"site-low_temperature_generation_mwh\",\n        \"spill-electric_generation_mwh\",\n        \"spill-electric_load_mwh\",\n        \"spill-high_temperature_generation_mwh\",\n        \"spill-low_temperature_generation_mwh\",\n        \"spill-high_temperature_load_mwh\",\n        \"spill-low_temperature_load_mwh\",\n        \"spill-gas_consumption_mwh\",\n        \"battery-electric_charge_mwh\",\n        \"battery-electric_charge_binary\",\n        \"battery-electric_discharge_mwh\",\n        \"battery-electric_discharge_binary\",\n        \"battery-electric_loss_mwh\",\n        \"battery-electric_initial_charge_mwh\",\n        \"battery-electric_final_charge_mwh\",\n        \"total-electric_generation_mwh\",\n        \"total-electric_load_mwh\",\n        \"total-high_temperature_generation_mwh\",\n        \"total-low_temperature_generation_mwh\",\n        \"total-high_temperature_load_mwh\",\n        \"total-low_temperature_load_mwh\",\n        \"total-gas_consumption_mwh\",\n        \"total-electric_charge_mwh\",\n        \"total-electric_discharge_mwh\",\n        \"total-spills_mwh\",\n        \"total-electric_loss_mwh\",\n        \"site-electricity_balance_mwh\",\n    ],\n)\n</code></pre>"},{"location":"assets/battery/#validation","title":"Validation","text":"<p>A natural response when you get access to something someone else built is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the battery asset.</p>"},{"location":"assets/battery/#price-dispatch-behaviour","title":"Price Dispatch Behaviour","text":"<p>Let's optimize a battery using a sequence of five prices.</p> <p>We expect that the battery will charge when prices are low, and will discharge when prices are high.</p> <p>In <code>energypylinear</code>, a positive site electricity balance is importing, and a negative site electricity balance is exporting.</p> <pre><code>import energypylinear as epl\n\nasset = epl.Battery(\n    electricity_prices=[10, -50, 200, -50, 200],\n)\nsimulation = asset.optimize(verbose=3)\nprint(simulation.results[[\"site-electricity_prices\", \"site-electricity_balance_mwh\"]])\n</code></pre> <pre><code>   site-electricity_prices  site-electricity_balance_mwh\n0                     10.0                      0.444444\n1                    -50.0                      2.000000\n2                    200.0                     -2.000000\n3                    -50.0                      2.000000\n4                    200.0                     -2.000000\n</code></pre> <p>As expected, the battery charges (with a site that is positive) when prices are low and discharges (with a negative site electricity balance) when prices are high.</p> <p>Now let's change the prices and see how the dispatch changes:</p> <pre><code>import energypylinear as epl\n\nasset = epl.Battery(\n    electricity_prices=[200, -50, -50, 200, 220],\n)\nsimulation = asset.optimize(verbose=3)\nprint(simulation.results[[\"site-electricity_prices\", \"site-electricity_balance_mwh\"]])\n</code></pre> <pre><code>   site-electricity_prices  site-electricity_balance_mwh\n0                    200.0                           0.0\n1                    -50.0                           2.0\n2                    -50.0                           2.0\n3                    200.0                          -1.6\n4                    220.0                          -2.0\n</code></pre> <p>As expected, the battery continues to charge during low electricity price intervals, and discharge when electricity prices are high.</p>"},{"location":"assets/battery/#battery-energy-balance","title":"Battery Energy Balance","text":"<p>Let's return to our original set of prices and check the energy balance of the battery:</p> <pre><code>import pandas as pd\nimport energypylinear as epl\n\npd.set_option(\"display.max_columns\", 30)\npd.set_option(\"display.width\", 400)\n\nasset = epl.Battery(\n    electricity_prices=[10, -50, 200, -50, 200],\n)\nsimulation = asset.optimize(verbose=3)\n\nchecks = epl.check_results(simulation.results, verbose=3)\nbalance = checks[\"electricity-balance\"]\nprint(balance)\n</code></pre> <pre><code>      input  accumulation  output  balance    import  generation  export  load    charge  discharge      loss  spills  soc\n0  0.444444     -0.444444     0.0     True  0.444444         0.0     0.0     0  0.444444        0.0  0.044444     0.0  0.0\n1  2.000000     -2.000000     0.0     True  2.000000         0.0     0.0     0  2.000000        0.0  0.200000     0.0  0.0\n2  0.000000      2.000000     2.0     True  0.000000         0.0     2.0     0  0.000000        2.0  0.000000     0.0  0.0\n3  2.000000     -2.000000     0.0     True  2.000000         0.0     0.0     0  2.000000        0.0  0.200000     0.0  0.0\n4  0.000000      2.000000     2.0     True  0.000000         0.0     2.0     0  0.000000        2.0  0.000000     0.0  0.0\n</code></pre> <p>In the first interval, we charge the battery with <code>0.444444 MWh</code> - <code>0.4 MWh</code> goes into increasing the battery state of charge from <code>0.0 MWh</code> to <code>0.4 MWh</code>, with the balance <code>0.044444 MWh</code> going to battery losses.</p>"},{"location":"assets/battery/#battery-efficiency","title":"Battery Efficiency","text":"<p>We can validate the performance of the battery efficiency by checking the losses across different battery efficiencies:</p> <pre><code>import numpy as np\nimport pandas as pd\nimport energypylinear as epl\n\nnp.random.seed(42)\nprices = np.random.uniform(-100, 100, 12) + 100\n\nout = []\nfor efficiency_pct in [1.0, 0.9, 0.8]:\n    asset = epl.Battery(\n        power_mw=4,\n        capacity_mwh=10,\n        efficiency_pct=efficiency_pct,\n        electricity_prices=prices,\n    )\n    simulation = asset.optimize(\n        objective=\"price\",\n        verbose=3\n    )\n    results = simulation.results\n    out.append(\n        {\n            \"eff_pct\": efficiency_pct,\n            \"charge_mwh\": results[\"battery-electric_charge_mwh\"].sum(),\n            \"discharge_mwh\": results[\"battery-electric_discharge_mwh\"].sum(),\n            \"loss_mwh\": results[\"battery-electric_loss_mwh\"].sum(),\n            \"prices_$_mwh\": results[\"site-electricity_prices\"].mean(),\n            \"import_mwh\": results[\"site-import_power_mwh\"].sum(),\n            \"objective\": (results[\"site-import_power_mwh\"] - results[\"site-export_power_mwh\"] * results[\"site-electricity_prices\"]).sum(),\n        }\n    )\n\nprint(pd.DataFrame(out))\n</code></pre> <pre><code>   eff_pct  charge_mwh  discharge_mwh  loss_mwh  prices_$_mwh  import_mwh    objective\n0      1.0   18.000000           18.0  0.000000    103.197695   18.000000 -3018.344310\n1      0.9   19.111111           17.2  1.911111    103.197695   19.111111 -2893.086854\n2      0.8   20.000000           16.0  4.000000    103.197695   20.000000 -2719.962419\n</code></pre> <p>From the above we observe the following as efficiency decreases:</p> <ul> <li>a reduction in the amount discharged <code>discharge_mwh</code>,</li> <li>an increase in battery losses <code>loss_mwh</code>,</li> <li>a increase in the objective function, which is an increase in cost.</li> </ul>"},{"location":"assets/battery/#state-of-charge-power-ratings","title":"State of Charge &amp; Power Ratings","text":"<p>We can demonstrate the state of charge and battery power settings by first optimizing a battery and showing it's plot:</p> <pre><code>import numpy as np\nimport energypylinear as epl\n\nnp.random.seed(42)\nelectricity_prices = np.random.normal(100, 10, 10).tolist()\n\nasset = epl.Battery(power_mw=2, capacity_mwh=4, electricity_prices=electricity_prices)\nresults = asset.optimize()\nasset.plot(results, path=\"./docs/docs/static/battery.png\")\n</code></pre> <p></p> <p>Takeaways:</p> <ul> <li>the battery state of charge is constrained between 0 and 4 MWh,</li> <li>the battery power rating is constrained between -2 and 2 MW,</li> <li>battery SOC starts empty and ends empty.</li> </ul> <pre><code>import numpy as np\nimport energypylinear as epl\n\nnp.random.seed(42)\n\nasset = epl.Battery(\n    power_mw=4,\n    capacity_mwh=8,\n    electricity_prices=np.random.normal(100, 10, 10),\n    initial_charge_mwh=1.0,\n    final_charge_mwh=3.0\n)\nresults = asset.optimize()\nasset.plot(results, path=\"./docs/docs/static/battery-fast.png\")\n</code></pre> <p></p> <p>Takeaways:</p> <ul> <li>battery SOC starts at 1 MWh and ends at 3 MWh.</li> </ul>"},{"location":"assets/chp/","title":"Combined Heat & Power","text":"<p>The <code>epl.CHP</code> asset is suitable for modelling combined heat and power (CHP) systems.  </p> <p>It can generate electricity, high &amp; low temperature heat from natural gas.</p>"},{"location":"assets/chp/#assumptions","title":"Assumptions","text":"<p>The <code>epl.CHP</code> is configured with electric, high and low temperature thermal efficiencies. This allows modelling open cycle generators, gas engines and gas turbines.</p> <p>When optimizing, we can use interval data for the high and low temperature loads.  </p> <p>The high and low temperature loads will be met by gas boilers if the CHP chooses not to generate, or cannot meet thermal demands.  High temperature heat can be let-down into low temperature heat.</p> <p>The <code>epl.CHP</code> is allowed to dump both high temperature and low temperature heat.</p>"},{"location":"assets/chp/#use","title":"Use","text":"<p>You can optimize a single CHP with <code>epl.CHP</code>:</p> <pre><code>import energypylinear as epl\n\n#  100 MWe gas turbine\nasset = epl.CHP(\n    electric_power_max_mw=100,\n    electric_power_min_mw=50,\n    electric_efficiency_pct=0.3,\n    high_temperature_efficiency_pct=0.5,\n)\n\n#  100 MWe gas engine\nasset = epl.CHP(\n    electric_power_max_mw=100,\n    electric_power_min_mw=10,\n    electric_efficiency_pct=0.4,\n    high_temperature_efficiency_pct=0.2,\n    low_temperature_efficiency_pct=0.2,\n    electricity_prices=[100, 50, 200, -100, 0, 200, 100, -100],\n    high_temperature_load_mwh=[100, 50, 200, 40, 0, 200, 100, 100],\n    low_temperature_load_mwh=20\n)\n\nsimulation = asset.optimize()\n\nassert all(\n    simulation.results.columns\n    == [\n        \"site-import_power_mwh\",\n        \"site-export_power_mwh\",\n        \"site-electricity_prices\",\n        \"site-export_electricity_prices\",\n        \"site-electricity_carbon_intensities\",\n        \"site-gas_prices\",\n        \"site-electric_load_mwh\",\n        \"site-high_temperature_load_mwh\",\n        \"site-low_temperature_load_mwh\",\n        \"site-low_temperature_generation_mwh\",\n        \"chp-electric_generation_mwh\",\n        \"chp-gas_consumption_mwh\",\n        \"chp-high_temperature_generation_mwh\",\n        \"chp-low_temperature_generation_mwh\",\n        \"boiler-high_temperature_generation_mwh\",\n        \"boiler-gas_consumption_mwh\",\n        \"valve-high_temperature_load_mwh\",\n        \"valve-low_temperature_generation_mwh\",\n        \"total-electric_generation_mwh\",\n        \"total-electric_load_mwh\",\n        \"total-high_temperature_generation_mwh\",\n        \"total-low_temperature_generation_mwh\",\n        \"total-high_temperature_load_mwh\",\n        \"total-low_temperature_load_mwh\",\n        \"total-gas_consumption_mwh\",\n        \"total-electric_charge_mwh\",\n        \"total-electric_discharge_mwh\",\n        \"total-spills_mwh\",\n        \"total-electric_loss_mwh\",\n        \"site-electricity_balance_mwh\",\n    ]\n)\n</code></pre>"},{"location":"assets/evs/","title":"Electric Vehicles","text":"<p>The <code>epl.EVs</code> asset is suitable for modelling electric vehicle charging. One asset can operate many electric vehicle chargers that supply electricity to many electric vehicle charge events.</p> <p>The electric vehicle asset will optimize the dispatch of the chargers to supply electricity to the charge events. The asset can do both grid to vehicle and vehicle to grid electricity flow with a <code>allows_evs_discharge</code> flag.</p>"},{"location":"assets/evs/#assumptions","title":"Assumptions","text":"<p>Electric vehicle chargers are configured by the charger power output, given as <code>charger_mws</code>.</p> <p>A <code>charge_event</code> is a time interval where an electric vehicle can be charged.  This is given as a boolean 2D array, with one binary digit for each charge event, interval pairs.</p> <p>Each charge event has a required amount of electricity <code>charge_event_mwh</code>, that can be delivered when the <code>charge_event</code> is 1.  The model is constrained so that each charge event receives all of it's <code>charge_event_mwh</code>.</p>"},{"location":"assets/evs/#use","title":"Use","text":"<p>Optimize two 100 MWe chargers for 4 charge events over 5 intervals:</p> <pre><code>import energypylinear as epl\n\nelectricity_prices = [-100, 50, 30, 50, 40]\ncharge_events = [\n    [1, 0, 0, 0, 0],\n    [0, 1, 1, 1, 0],\n    [0, 0, 0, 1, 1],\n    [0, 1, 0, 0, 0],\n]\n\n#  2 100 MW EV chargers\nasset = epl.EVs(\n    chargers_power_mw=[100, 100],\n    charge_events_capacity_mwh=[50, 100, 30, 40],\n    charger_turndown=0.1,\n    electricity_prices=electricity_prices,\n    charge_events=charge_events,\n    include_spill=True\n)\n\nsimulation = asset.optimize()\n\nassert all(\n    simulation.results.columns\n    == [\n        \"site-import_power_mwh\",\n        \"site-export_power_mwh\",\n        \"site-electricity_prices\",\n        \"site-export_electricity_prices\",\n        \"site-electricity_carbon_intensities\",\n        \"site-gas_prices\",\n        \"site-electric_load_mwh\",\n        \"site-high_temperature_load_mwh\",\n        \"site-low_temperature_load_mwh\",\n        \"site-low_temperature_generation_mwh\",\n        \"spill-electric_generation_mwh\",\n        \"spill-electric_load_mwh\",\n        \"spill-high_temperature_generation_mwh\",\n        \"spill-low_temperature_generation_mwh\",\n        \"spill-high_temperature_load_mwh\",\n        \"spill-low_temperature_load_mwh\",\n        \"spill-gas_consumption_mwh\",\n        \"evs-charger-0-electric_charge_mwh\",\n        \"evs-charger-0-electric_charge_binary\",\n        \"evs-charger-0-electric_discharge_mwh\",\n        \"evs-charger-0-electric_discharge_binary\",\n        \"evs-charger-0-electric_loss_mwh\",\n        \"evs-charger-1-electric_charge_mwh\",\n        \"evs-charger-1-electric_charge_binary\",\n        \"evs-charger-1-electric_discharge_mwh\",\n        \"evs-charger-1-electric_discharge_binary\",\n        \"evs-charger-1-electric_loss_mwh\",\n        \"evs-charge-event-0-electric_charge_mwh\",\n        \"evs-charge-event-0-electric_discharge_mwh\",\n        \"evs-charge-event-0-electric_loss_mwh\",\n        \"evs-charge-event-1-electric_charge_mwh\",\n        \"evs-charge-event-1-electric_discharge_mwh\",\n        \"evs-charge-event-1-electric_loss_mwh\",\n        \"evs-charge-event-2-electric_charge_mwh\",\n        \"evs-charge-event-2-electric_discharge_mwh\",\n        \"evs-charge-event-2-electric_loss_mwh\",\n        \"evs-charge-event-3-electric_charge_mwh\",\n        \"evs-charge-event-3-electric_discharge_mwh\",\n        \"evs-charge-event-3-electric_loss_mwh\",\n        \"evs-charge-event-0-initial_soc_mwh\",\n        \"evs-charge-event-1-initial_soc_mwh\",\n        \"evs-charge-event-2-initial_soc_mwh\",\n        \"evs-charge-event-3-initial_soc_mwh\",\n        \"evs-charge-event-0-final_soc_mwh\",\n        \"evs-charge-event-1-final_soc_mwh\",\n        \"evs-charge-event-2-final_soc_mwh\",\n        \"evs-charge-event-3-final_soc_mwh\",\n        \"evs-charger-spill-evs-electric_charge_mwh\",\n        \"evs-charger-spill-evs-electric_charge_binary\",\n        \"evs-charger-spill-evs-electric_discharge_mwh\",\n        \"evs-charger-spill-evs-electric_discharge_binary\",\n        \"evs-charger-spill-evs-electric_loss_mwh\",\n        \"total-electric_generation_mwh\",\n        \"total-electric_load_mwh\",\n        \"total-high_temperature_generation_mwh\",\n        \"total-low_temperature_generation_mwh\",\n        \"total-high_temperature_load_mwh\",\n        \"total-low_temperature_load_mwh\",\n        \"total-gas_consumption_mwh\",\n        \"total-electric_charge_mwh\",\n        \"total-electric_discharge_mwh\",\n        \"total-spills_mwh\",\n        \"total-electric_loss_mwh\",\n        \"site-electricity_balance_mwh\",\n    ],\n)\n</code></pre>"},{"location":"assets/evs/#validation","title":"Validation","text":"<p>A natural response when you get access to something someone else built is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the EV asset.</p>"},{"location":"assets/evs/#fully-constrained-ev-charging","title":"Fully Constrained EV Charging","text":"<pre><code>import energypylinear as epl\n\nasset = epl.EVs(\n    chargers_power_mw=[100, 100],\n    charge_events_capacity_mwh=[50, 100, 30],\n    charger_turndown=0.0,\n    charge_event_efficiency=1.0,\n    electricity_prices=[-100, 50, 30, 10, 40],\n    charge_events=[\n        [1, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 0],\n    ]\n)\nsimulation = asset.optimize()\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-1.png\")\n</code></pre> <p>The third charger is the spill charger.</p> <p></p>"},{"location":"assets/evs/#expanding-a-charge-event-window","title":"Expanding a Charge Event Window","text":"<p>Let's expand out the charge event window to the last three intervals for the last charge event:</p> <pre><code>import energypylinear as epl\n\nasset = epl.EVs(\n    chargers_power_mw=[100, 100],\n    charge_events_capacity_mwh=[50, 100, 30],\n    charger_turndown=0.0,\n    charge_event_efficiency=1.0,\n    electricity_prices=[-100, 50, 300, 10, 40],\n    charge_events=[\n        [1, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 1, 1],\n    ]\n)\nsimulation = asset.optimize()\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-2.png\")\n</code></pre> <p>Now we see that the charge has happened in interval 3, this is because electricity prices are lowest in this interval.</p> <p></p>"},{"location":"assets/evs/#overlapping-charge-events","title":"Overlapping Charge Events","text":"<p>When charge events overlap at low prices, both (but only two) chargers are used:</p> <pre><code>import energypylinear as epl\n\nasset = epl.EVs(\n    chargers_power_mw=[100, 100],\n    charge_events_capacity_mwh=[50, 100, 30],\n    charger_turndown=0.0,\n    charge_event_efficiency=1.0,\n    electricity_prices=[-100, 50, 300, 10, 40],\n    charge_events=[\n        [1, 0, 0, 1, 0],\n        [0, 1, 1, 1, 1],\n        [0, 0, 1, 1, 1],\n    ]\n)\nsimulation = asset.optimize()\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-3.png\")\n</code></pre> <p></p>"},{"location":"assets/evs/#adding-v2g","title":"Adding V2G","text":"<pre><code>import energypylinear as epl\n\nasset = epl.EVs(\n    chargers_power_mw=[100, 100],\n    charge_events_capacity_mwh=[50, 100, 30],\n    charger_turndown=0.0,\n    charge_event_efficiency=1.0,\n    electricity_prices=[-100, 50, 300, 10, 40],\n    charge_events=[\n        [1, 0, 0, 0, 0],\n        [0, 1, 1, 1, 1],\n        [0, 0, 1, 1, 1],\n    ],\n)\nsimulation = asset.optimize(\n    flags=epl.Flags(allow_evs_discharge=True)\n)\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-4.png\")\n</code></pre> <p>The key takeaway here is that we discharge during interval 2.  All our charge events still end up at the correct state of charge at the end of the program.</p>"},{"location":"assets/evs/#spill-chargers","title":"Spill Chargers","text":"<pre><code>import energypylinear as epl\n\nasset = epl.EVs(\n    chargers_power_mw=[100, 100],\n    charge_events_capacity_mwh=[50, 100, 30, 500],\n    charger_turndown=0.0,\n    charge_event_efficiency=1.0,\n    electricity_prices=[-100, 50, 300, 10, 40],\n    charge_events=[\n        [1, 0, 0, 0, 0],\n        [0, 1, 1, 1, 1],\n        [0, 0, 1, 1, 1],\n        [1, 0, 0, 0, 0],\n    ],\n)\nsimulation = asset.optimize(\n    flags=epl.Flags(allow_evs_discharge=True)\n)\nasset.plot(simulation, path=\"./docs/docs/static/ev-validation-5.png\")\n</code></pre> <p>Key takeaway here is the use of the spill charger - we have a 500 MWh charge event, but only 200 MWh of capacity.  We meet the remaining demand from a spill charger.</p> <p>This allows the linear program to be feasible, while communicating directly which intervals or charge events are causing the mismatch between charge event demand and spill charger capacity.</p> <p></p>"},{"location":"assets/heat-pump/","title":"Heat Pump","text":"<p>The <code>epl.HeatPump</code> asset is suitable for modelling electric heat pumps. </p> <p>It uses electricity to convert low temperature heat to high temperature heat.</p>"},{"location":"assets/heat-pump/#assumptions","title":"Assumptions","text":"<p>When using <code>epl.HeatPump.optimize</code>, the alternative to the heat pump is generating high temperature heat from a gas boiler.  Under the hood of <code>epl.HeatPump.optimize</code>, a <code>epl.Boiler</code> asset is used to supply the balance of high temperature heat demand of the site.</p> <p>The gas price is important as the alternative to using a heat pump to supply the <code>high_temperature_load_mwh</code> is using a natural gas boiler.</p> <p>In order for the heat pump to work, it needs to have both a source of low temperature heat and a sink of high temperature heat.</p> <p>The <code>high_temperature_load_mwh</code> is the amount of heat consumed by the site, and <code>low_temperature_generation_mwh</code> is the amount of available low temperature heat.</p>"},{"location":"assets/heat-pump/#use","title":"Use","text":"<pre><code>import energypylinear as epl\n\nasset = epl.HeatPump(\n    electric_power_mw=1.0,\n    cop=2,\n    gas_prices=20,\n    electricity_prices=[100, -100],\n    high_temperature_load_mwh=3.0,\n    low_temperature_generation_mwh=3.0,\n    include_spill=True\n)\nsimulation = asset.optimize(verbose=False)\nprint(\n    simulation.results[\n        [\n            \"site-electricity_prices\",\n            \"heat-pump-electric_load_mwh\",\n            \"heat-pump-low_temperature_load_mwh\",\n            \"heat-pump-high_temperature_generation_mwh\",\n        ]\n    ]\n)\n\nassert all(\n    simulation.results.columns\n    == [\n        \"site-import_power_mwh\",\n        \"site-export_power_mwh\",\n        \"site-electricity_prices\",\n        \"site-export_electricity_prices\",\n        \"site-electricity_carbon_intensities\",\n        \"site-gas_prices\",\n        \"site-electric_load_mwh\",\n        \"site-high_temperature_load_mwh\",\n        \"site-low_temperature_load_mwh\",\n        \"site-low_temperature_generation_mwh\",\n        \"spill-electric_generation_mwh\",\n        \"spill-electric_load_mwh\",\n        \"spill-high_temperature_generation_mwh\",\n        \"spill-low_temperature_generation_mwh\",\n        \"spill-high_temperature_load_mwh\",\n        \"spill-low_temperature_load_mwh\",\n        \"spill-gas_consumption_mwh\",\n        \"boiler-high_temperature_generation_mwh\",\n        \"boiler-gas_consumption_mwh\",\n        \"valve-high_temperature_load_mwh\",\n        \"valve-low_temperature_generation_mwh\",\n        \"heat-pump-electric_load_mwh\",\n        \"heat-pump-low_temperature_load_mwh\",\n        \"heat-pump-high_temperature_generation_mwh\",\n        \"total-electric_generation_mwh\",\n        \"total-electric_load_mwh\",\n        \"total-high_temperature_generation_mwh\",\n        \"total-low_temperature_generation_mwh\",\n        \"total-high_temperature_load_mwh\",\n        \"total-low_temperature_load_mwh\",\n        \"total-gas_consumption_mwh\",\n        \"total-electric_charge_mwh\",\n        \"total-electric_discharge_mwh\",\n        \"total-spills_mwh\",\n        \"total-electric_loss_mwh\",\n        \"site-electricity_balance_mwh\",\n    ],\n)\n</code></pre> <pre><code>{\n    'n_spills': 1,\n    'spill_columns': 8,\n    'spills': {'spill-low_temperature_load_mwh': 5.0},\n    'event': 'warn_spills',\n    'timestamp': '2023-09-08T00:41:33.743617Z',\n    'logger':'default_logger',\n    'level': 'warning'\n}\n   site-electricity_prices  heat-pump-electric_load_mwh  heat-pump-low_temperature_load_mwh  heat-pump-high_temperature_generation_mwh\n0                      100                          0.0                                 0.0                                        0.0\n1                     -100                          1.0                                 1.0                                        2.0\n</code></pre> <p>Under the hood the heat pump asset also includes a <code>epl.Spill</code>, which allows dumping of excess low temperature heat, and a <code>epl.Valve</code> to allow high temperature heat to flow into low temperature heat.</p> <p>The combination of a <code>epl.Spill</code>, <code>epl.Valve</code> and negative electricity prices can lead to the heat pump using electricity to generate high temperature heat which is then dumped as low temperature heat.  For this reason the <code>epl.HeatPump</code> asset includes a <code>include_valve: bool</code> option to turn off the valve.</p> <p>You could also setup an <code>epl.Site</code> with other assets that generate high temperature heat to explore different tradeoffs (such as a heat pump using low temperature heat from a CHP system).</p>"},{"location":"assets/heat-pump/#validation","title":"Validation","text":"<p>A natural response when you get access to something someone else built is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the heat pump asset.</p>"},{"location":"assets/heat-pump/#price-dispatch","title":"Price Dispatch","text":"<p>Let's optimize the heat pump in two intervals - the first with a high electricity price of <code>100</code> and the second with a low  electricity price of <code>-100</code>.</p> <p>Our expectation is that the heat pump will not operate in the first interval, but will operate in the second interval:</p> <pre><code>import pandas as pd\nimport energypylinear as epl\n\npd.set_option(\"display.max_columns\", 4)\npd.set_option('display.width', 1000)\n\nasset = epl.HeatPump(\n    electric_power_mw=1.0,\n    cop=2,\n    gas_prices=20,\n    electricity_prices=[100, -100],\n    high_temperature_load_mwh=3.0,\n    low_temperature_generation_mwh=4.0,\n    include_spill=True\n)\nsimulation = asset.optimize(verbose=4)\nprint(simulation.results[\n    [\n        \"site-electricity_prices\",\n        \"heat-pump-electric_load_mwh\",\n        \"boiler-high_temperature_generation_mwh\"\n    ]\n])\n</code></pre> <pre><code>   site-electricity_prices  heat-pump-electric_load_mwh  boiler-high_temperature_generation_mwh\n0                    100.0                          0.0                                     3.0\n1                   -100.0                          1.0                                     1.0\n</code></pre> <p>For the first interval, with an electricity price of <code>100</code>, we see that:</p> <ul> <li>our heat pump has not operated (<code>heat-pump-electric_load_mwh=0</code>),</li> <li>our <code>3.0 MWh</code> of high temperature heat demand has been generated by the gas boiler.</li> </ul> <p>For the second interval, with an electricity price of <code>-100</code>, we see that:</p> <ul> <li>our heat pump is operating at <code>1.0 MWe</code>, which means we expect <code>2.0 MWh</code> of high temperature heat,</li> <li>only <code>1.0 MWh</code> of high temperature heat demand has been generated by the gas boiler.</li> </ul>"},{"location":"assets/heat-pump/#heat-balance","title":"Heat Balance","text":""},{"location":"assets/heat-pump/#without-a-valve","title":"Without a Valve","text":"<p>Let's first optimize a heat pump without a high temperature to low temperature valve, which stops heat from flowing from high to low temperature.</p> <p>We use a negative electricity price of <code>-100</code> for each interval, to force the heat pump to operate.</p> <pre><code>import energypylinear as epl\n\nasset = epl.HeatPump(\n    electric_power_mw=1.0,\n    cop=2,\n    gas_prices=20,\n    electricity_prices=[-100, -100, -100],\n    high_temperature_load_mwh=[3.0, 0.5, 3.0],\n    low_temperature_generation_mwh=[4.0, 4.0, 0.5],\n    include_spill=True,\n    include_valve=False\n)\nsimulation = asset.optimize(\n    verbose=4,\n)\nprint(simulation.results[\n    [\n        \"site-high_temperature_load_mwh\",\n        \"site-low_temperature_generation_mwh\",\n        \"spill-low_temperature_load_mwh\",\n        \"heat-pump-electric_load_mwh\",\n        \"heat-pump-high_temperature_generation_mwh\",\n        \"boiler-high_temperature_generation_mwh\"\n    ]\n])\n</code></pre> <pre><code>   site-high_temperature_load_mwh  site-low_temperature_generation_mwh  spill-low_temperature_load_mwh  heat-pump-electric_load_mwh  heat-pump-high_temperature_generation_mwh  boiler-high_temperature_generation_mwh\n0                             3.0                                  4.0                            3.00                         1.00                                        2.0                                     1.0\n1                             0.5                                  4.0                            3.75                         0.25                                        0.5                                     0.0\n2                             3.0                                  0.5                            0.00                         0.50                                        1.0                                     2.0\n</code></pre> <p>In the first interval we are unconstrained in terms of heat - our heat pump runs at the full <code>1.0 MWe</code> load.</p> <p>In the second interval we have a limited amount of high temperature heat load in the site, which constrains the heat pump.</p> <p>In the third interval we have a limited amount of low temperature heat generation in the site, which again constrains how much the heat pump can run.</p>"},{"location":"assets/heat-pump/#with-a-valve","title":"With a Valve","text":"<p>Lets now optimize a heat pump with a high temperature to low temperature valve.</p> <p>This allows heat to flow from high to low temperature, which means our boiler can generate high temperature heat that ends up as low temperature heat input into the heat pump.</p> <p>This is a pretty bizarre situation, that is optimal because of our negative electricity price.</p> <pre><code>import energypylinear as epl\n\nasset = epl.HeatPump(\n    electric_power_mw=1.0,\n    cop=2,\n    gas_prices=20,\n    electricity_prices=[-100, -100, -100],\n    high_temperature_load_mwh=[3.0, 0.5, 3.0],\n    low_temperature_generation_mwh=[4.0, 4.0, 0.0],\n    include_valve=True,\n    include_spill=True,\n)\nsimulation = asset.optimize(\n    verbose=4,\n)\nprint(simulation.results[\n    [\n        \"site-high_temperature_load_mwh\",\n        \"site-low_temperature_generation_mwh\",\n        \"spill-low_temperature_load_mwh\",\n        \"heat-pump-electric_load_mwh\",\n        \"heat-pump-high_temperature_generation_mwh\",\n        \"boiler-high_temperature_generation_mwh\"\n    ]\n])\n</code></pre> <pre><code>   site-high_temperature_load_mwh  site-low_temperature_generation_mwh  spill-low_temperature_load_mwh  heat-pump-electric_load_mwh  heat-pump-high_temperature_generation_mwh  boiler-high_temperature_generation_mwh\n0                             3.0                                  4.0                             3.0                          1.0                                        2.0                                     1.0\n1                             0.5                                  4.0                             4.5                          1.0                                        2.0                                     0.0\n2                             3.0                                  0.0                             0.0                          1.0                                        2.0                                     2.0\n</code></pre> <p>We now see that our heat pump operates for all three intervals.  It is no longer starved for low temperature heat input, as the boiler can generate this heat.</p>"},{"location":"assets/renewable-generator/","title":"Renewable Generator","text":"<p>The <code>epl.RenewableGenerator</code> asset is suitable for modelling wind or solar generation.</p>"},{"location":"assets/renewable-generator/#use","title":"Use","text":"<pre><code>import energypylinear as epl\n\nasset = epl.RenewableGenerator(\n    electricity_prices=[1.0, -0.5],\n    electric_generation_mwh=[100, 100],\n    electric_generation_lower_bound_pct=0.5,\n    name=\"wind\",\n)\nsimulation = asset.optimize(objective=\"price\")\n\nassert all(\n    simulation.results.columns\n    == [\n        \"site-import_power_mwh\",\n        \"site-export_power_mwh\",\n        \"site-electricity_prices\",\n        \"site-export_electricity_prices\",\n        \"site-electricity_carbon_intensities\",\n        \"site-gas_prices\",\n        \"site-electric_load_mwh\",\n        \"site-high_temperature_load_mwh\",\n        \"site-low_temperature_load_mwh\",\n        \"site-low_temperature_generation_mwh\",\n        \"wind-electric_generation_mwh\",\n        \"total-electric_generation_mwh\",\n        \"total-electric_load_mwh\",\n        \"total-high_temperature_generation_mwh\",\n        \"total-low_temperature_generation_mwh\",\n        \"total-high_temperature_load_mwh\",\n        \"total-low_temperature_load_mwh\",\n        \"total-gas_consumption_mwh\",\n        \"total-electric_charge_mwh\",\n        \"total-electric_discharge_mwh\",\n        \"total-spills_mwh\",\n        \"total-electric_loss_mwh\",\n        \"site-electricity_balance_mwh\",\n    ],\n)\n</code></pre> <p>This renewable generator will turn down when electricity prices are negative.</p>"},{"location":"assets/renewable-generator/#validation","title":"Validation","text":"<p>A natural response when you get access to something someone else built is to wonder - does this work correctly?</p> <p>This section will give you confidence in the implementation of the renewable generator asset.</p>"},{"location":"assets/renewable-generator/#carbon-dispatch-behaviour","title":"Carbon Dispatch Behaviour","text":"<p>Let's optimize the renewable generator asset in two intervals:</p> <ol> <li>a positive import electricity carbon intensity of <code>1.0 tC/MWh</code>,</li> <li>a negative import electricity carbon intensity of <code>-0.5 tC/MWh</code>.</li> </ol> <p>If we optimize our <code>epl.RenewableGenerator</code> asset with a lower bound on the electricity generation of <code>1.0</code>, we generate the full <code>100 MW</code> in each interval:</p> <pre><code>import energypylinear as epl\n\nelectricity_carbon_intensities = [1.0, -0.5]\nelectric_generation_mwh=[100, 100]\nelectric_generation_lower_bound_pct=1.0\n\nasset = epl.RenewableGenerator(\n    electricity_carbon_intensities=electricity_carbon_intensities,\n    electric_generation_mwh=electric_generation_mwh,\n    name=\"wind\",\n    electric_generation_lower_bound_pct=electric_generation_lower_bound_pct\n)\nsimulation = asset.optimize(objective=\"carbon\", verbose=3)\nprint(simulation.results[\n    [\n        \"site-electricity_carbon_intensities\",\n        \"site-export_power_mwh\",\n        \"wind-electric_generation_mwh\",\n    ]\n])\n</code></pre> <pre><code>   site-electricity_carbon_intensities  site-export_power_mwh  wind-electric_generation_mwh\n0                                  1.0                  100.0                         100.0\n1                                 -0.5                  100.0                         100.0\n</code></pre> <p>If we change our lower bound to <code>0.5</code>, our renewable generator asset will generate less electricity during the second, negative carbon intensity interval:</p> <pre><code>import energypylinear as epl\n\nelectricity_carbon_intensities = [1.0, -0.5]\nelectric_generation_mwh=[100, 100]\nelectric_generation_lower_bound_pct=0.5\n\nasset = epl.RenewableGenerator(\n    electricity_carbon_intensities=electricity_carbon_intensities,\n    electric_generation_mwh=electric_generation_mwh,\n    name=\"wind\",\n    electric_generation_lower_bound_pct=electric_generation_lower_bound_pct\n)\nsimulation = asset.optimize(objective=\"carbon\", verbose=3)\nprint(simulation.results[\n    [\n        \"site-electricity_carbon_intensities\",\n        \"site-export_power_mwh\",\n        \"wind-electric_generation_mwh\",\n    ]\n])\n</code></pre> <pre><code>   site-electricity_carbon_intensities  site-export_power_mwh  wind-electric_generation_mwh\n0                                  1.0                  100.0                         100.0\n1                                 -0.5                   50.0                          50.0\n</code></pre>"},{"location":"how-to/battery-degradation/","title":"Battery Degradation","text":"<p>Battery performance reducing is known as battery degradation. Battery degradation can occur over time or with battery use.</p> <p>The performance of a battery is defined by the parameters of power (MW), capacity (MWh) and efficiency (%).</p> <p><code>energypylinear</code> does not model battery degradation within a single simulation.  Parameters like capacity or efficiency are held constant across a simulation.</p> <p>Degradation can be handled by splitting up the battery lifetime into multiple simulations, with different parameters used in different simulations.</p>"},{"location":"how-to/battery-degradation/#modelling-a-single-year-in-monthly-chunks","title":"Modelling a Single Year in Monthly Chunks","text":"<p>To handle battery degradation over a year, we will split the year into 12 months and run a simulation for each month:</p> <pre><code>import numpy as np\nimport pandas as pd\n\nimport energypylinear as epl\n\nnp.random.seed(42)\ndays = 35\ndataset = pd.DataFrame({\n    \"timestamp\": pd.date_range(\"2021-01-01\", periods=days * 24, freq=\"h\"),\n    \"prices\": np.random.normal(-1000, 1000, days * 24) + 100\n})\nbattery_params = {\n    \"power_mw\": 4,\n    \"capacity_mwh\": 10,\n    \"efficiency_pct\": 0.9,\n    \"freq_mins\": 60\n}\n\nresults = []\nobjs = []\nfor month, group in dataset.groupby(dataset['timestamp'].dt.month):\n    print(f\"Month {month}\")\n    battery = epl.Battery(electricity_prices=group['prices'], **battery_params)\n    simulation = battery.optimize(verbose=3)\n    results.append(simulation.results)\n    objs.append(simulation.status.objective)\n\nyear = pd.concat(results)\nassert year.shape[0] == days * 24\naccount = epl.get_accounts(year, verbose=3)\nnp.testing.assert_allclose(account.profit, -1 * sum(objs))\nprint(account)\n</code></pre> <pre><code>Month 1\nMonth 2\n&lt;Accounts profit=2501349.07 emissions=15.7333&gt;\n</code></pre> <p>The results above do not include any battery degradation - battery parameters are the same at the start of each month.</p>"},{"location":"how-to/battery-degradation/#modelling-degradation","title":"Modelling Degradation","text":"<p>To model degradation, we need to take a view on how our battery parameters change over time.</p> <p>For our simulation, we will model:</p> <ul> <li>battery power decays by 0.1 MW for each 150 MWh of battery charge,</li> <li>battery capacity decays by 0.1 MWh for each 150 MWh of battery charge,</li> <li>battery efficiency decays by 0.1% over 30 days.</li> </ul> <pre><code>def get_battery_params(cumulative_charge_mwh: float = 0, cumulative_days: float = 0) -&gt; dict:\n    \"\"\"Get degraded battery parameters based on usage and time.\"\"\"\n    power_decay_mw_per_mwh = 0.1 / 150\n    capacity_decay_mwh_per_mwh = 0.1 / 150\n    efficiency_decay_pct_per_day = 0.1 / 30\n    return {\n        \"power_mw\": 4 - power_decay_mw_per_mwh * cumulative_charge_mwh,\n        \"capacity_mwh\": 10 - capacity_decay_mwh_per_mwh * cumulative_charge_mwh,\n        \"efficiency_pct\": 0.9 - efficiency_decay_pct_per_day * cumulative_days,\n        \"freq_mins\": 60\n    }\n</code></pre> <p>For a fresh battery, our battery parameters are:</p> <pre><code>print(get_battery_params())\n</code></pre> <pre><code>{'power_mw': 4.0, 'capacity_mwh': 10.0, 'efficiency_pct': 0.9, 'freq_mins': 60}\n</code></pre> <p>For a battery that has been charged with 300 MWh over 60 days, our battery parameters are:</p> <pre><code>print(get_battery_params(cumulative_charge_mwh=300, cumulative_days=60))\n</code></pre> <pre><code>{'power_mw': 3.8, 'capacity_mwh': 9.8, 'efficiency_pct': 0.7, 'freq_mins': 60}\n</code></pre>"},{"location":"how-to/battery-degradation/#modelling-a-single-year-in-monthly-chunks-with-degradation","title":"Modelling a Single Year in Monthly Chunks with Degradation","text":"<p>We can include our battery degradation model in our simulation by keeping track of our battery usage and updating the battery parameters at the start of each month:</p> <pre><code>import collections\n\nresults = []\ncumulative = collections.defaultdict(float)\nfor month, group in dataset.groupby(dataset['timestamp'].dt.month):\n    battery_params = get_battery_params(\n        cumulative_charge_mwh=cumulative['charge_mwh'],\n        cumulative_days=cumulative['days']\n    )\n    print(f\"Month: {month}, Battery Params: {battery_params}\")\n    battery = epl.Battery(electricity_prices=group['prices'], **battery_params)\n    simulation = battery.optimize(verbose=3)\n    results.append(simulation.results)\n    cumulative['charge_mwh'] += simulation.results['battery-electric_charge_mwh'].sum()\n    cumulative['days'] += group.shape[0] / 24\n\nyear = pd.concat(results)\nassert year.shape[0] == days * 24\naccount = epl.get_accounts(year, verbose=3)\nprint(account)\n</code></pre> <pre><code>Month: 1, Battery Params: {'power_mw': 4.0, 'capacity_mwh': 10.0, 'efficiency_pct': 0.9, 'freq_mins': 60}\nMonth: 2, Battery Params: {'power_mw': 3.0663703705399996, 'capacity_mwh': 9.06637037054, 'efficiency_pct': 0.7966666666666666, 'freq_mins': 60}\n&lt;Accounts profit=2460059.00 emissions=16.9273&gt;\n</code></pre>"},{"location":"how-to/battery-degradation/#full-example","title":"Full Example","text":"<pre><code>import collections\n\nimport numpy as np\nimport pandas as pd\n\nimport energypylinear as epl\n\ndef get_battery_params(cumulative_charge_mwh: float = 0, cumulative_days: float = 0) -&gt; dict:\n    \"\"\"Get degraded battery parameters based on usage and time.\"\"\"\n    power_decay_mw_per_mwh = 0.1 / 150\n    capacity_decay_mwh_per_mwh = 0.1 / 150\n    efficiency_decay_pct_per_day = 0.1 / 30\n    return {\n        \"power_mw\": 4 - power_decay_mw_per_mwh * cumulative_charge_mwh,\n        \"capacity_mwh\": 10 - capacity_decay_mwh_per_mwh * cumulative_charge_mwh,\n        \"efficiency_pct\": 0.9 - efficiency_decay_pct_per_day * cumulative_days,\n        \"freq_mins\": 60\n    }\n\nnp.random.seed(42)\ndays = 35\ndataset = pd.DataFrame({\n    \"timestamp\": pd.date_range(\"2021-01-01\", periods=days * 24, freq=\"h\"),\n    \"prices\": np.random.normal(-1000, 1000, days * 24) + 100\n})\n\nresults = []\ncumulative = collections.defaultdict(float)\nfor month, group in dataset.groupby(dataset['timestamp'].dt.month):\n    battery_params = get_battery_params(\n        cumulative_charge_mwh=cumulative['charge_mwh'],\n        cumulative_days=cumulative['days']\n    )\n    print(f\"Month: {month}, Battery Params: {battery_params}\")\n    battery = epl.Battery(electricity_prices=group['prices'], **battery_params)\n    simulation = battery.optimize(verbose=3)\n    results.append(simulation.results)\n    cumulative['charge_mwh'] += simulation.results['battery-electric_charge_mwh'].sum()\n    cumulative['days'] += group.shape[0] / 24\n\nyear = pd.concat(results)\nassert year.shape[0] == days * 24\naccount = epl.get_accounts(year, verbose=3)\nprint(account)\n</code></pre> <pre><code>Month: 1, Battery Params: {'power_mw': 4.0, 'capacity_mwh': 10.0, 'efficiency_pct': 0.9, 'freq_mins': 60}\nMonth: 2, Battery Params: {'power_mw': 3.0663703705399996, 'capacity_mwh': 9.06637037054, 'efficiency_pct': 0.7966666666666666, 'freq_mins': 60}\n&lt;Accounts profit=2460059.00 emissions=16.9273&gt;\n</code></pre>"},{"location":"how-to/complex-terms/","title":"Complex terms","text":"<p>In <code>energypylinear</code> you can use custom objective functions to define a custom set of incentives and costs in your linear program.</p> <p>The objective function will often be made up of simple terms, which are the product of a single linear variable (one per interval), interval data and a coefficient. </p> <p>Sites will however often have more complicated costs and revenues, that involve taking the minimum or maximum of a collection of variables.</p> <p>A complex custom objective term allows you to construct an objective function with a complex set of costs and revenues.</p>"},{"location":"how-to/complex-terms/#complex-objective-function-terms","title":"Complex Objective Function Terms","text":"<p><code>energypylinear</code> uses complex terms to include these more complicated incentives and costs in the objective function:</p> <pre><code>@dataclasses.dataclass\nclass FunctionTermTwoVariables:\n    \"\"\"A function term for constraining two variables.\n\n    Will add `i` terms to the objective function, where `i` is\n    the number of intervals in the simulation.\n\n    Will also add constraints to the linear program.\n\n    Attributes:\n        function: The function to apply to the two variables.\n        a: Left hand side variable.\n        b: Right hand side variable.\n        M: Big-M constant used in the constraints.\n        interval_data: The interval data variable, such as\n            `electricity_prices` or `gas_prices`.\n        coefficient: A constant multipler for the term.\n        type: The type of the term.\n    \"\"\"\n\n    function: typing.Literal[\"max_two_variables\", \"min_two_variables\"]\n    a: Term | float\n    b: Term | float\n    M: float\n    interval_data: str | None = None\n    coefficient: float = 1.0\n    type: typing.Literal[\"complex\"] = \"complex\"\n\n\n@dataclasses.dataclass\nclass FunctionTermManyVariables:\n    \"\"\"A function term for constraining many variables.\n\n    This will add 1 term to the objective function.\n\n    Will also add constraints to the linear program.\n\n    Attributes:\n        function: Function to apply to the many variables.\n        variables: Linear program variables to apply the function over.\n        M: Big-M constant used in the constraints.\n        interval_data: The interval data variable, such as\n            `electricity_prices` or `gas_prices`.\n        constant: A constant to include in the function alongside\n            the linear program variables.\n        coefficient: A constant multipler for the term.\n        type: The type of the term.\n    \"\"\"\n\n    function: typing.Literal[\"max_many_variables\", \"min_many_variables\"]\n    variables: Term\n    M: float\n    constant: float = 0.0\n    coefficient: float = 1.0\n    type: typing.Literal[\"complex\"] = \"complex\"\n</code></pre> <p>Currently the library includes four complex terms, which allow adding minimum or maximum constraints on collections of linear program variables and floats:</p> Function Number of Linear Variables Number of Floats Terms Added to Objective Function <code>min_two_variables</code> 1 or 2 0 or 1 Interval index length <code>max_two_variables</code> 1 or 2 0 or 1 Interval index length <code>max_many_variables</code> Interval index length 0 or 1 1 <code>min_many_variables</code> Interval index length 0 or 1 1"},{"location":"how-to/complex-terms/#examples","title":"Examples","text":""},{"location":"how-to/complex-terms/#maximum-demand-charge","title":"Maximum Demand Charge","text":"<p>A common incentive for many sites is a maximum demand charge, where a site will incur a cost based on the maximum site import over a length of time (commonly a month).</p> <p>We can model this using the <code>max_many_variables</code> function term, which will add a single term to the objective function that is the maximum of many linear program variables and a user supplied constant.</p> <p>We can demonstrate this by using an example of a site with a variable electric load, with a peak of 50 MW.</p> <p>We can first optimize the site with an objective function that does not include a demand charge:</p> <pre><code>import energypylinear as epl\n\nelectric_load_mwh = [30.0, 50.0, 10.0]\nelectricity_prices = [0.0, 0.0, 0.0]\ngas_prices = 20\n\nsite = epl.Site(\n    assets=[\n        epl.CHP(\n            electric_efficiency_pct=1.0,\n            electric_power_max_mw=50,\n            electric_power_min_mw=0,\n        )\n    ],\n    gas_prices=gas_prices,\n    electricity_prices=electricity_prices,\n    electric_load_mwh=electric_load_mwh,\n)\n\nno_demand_charge_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n        ]\n    },\n)\n</code></pre> <p>As expected for a site with low electricity prices, this CHP does not generate electricity in any interval:</p> <pre><code>print(no_demand_charge_simulation.results['chp-electric_generation_mwh'])\n</code></pre> <pre><code>0    0.0\n1    0.0\n2    0.0\nName: chp-electric_generation_mwh, dtype: float64\n</code></pre> <p>Let's now optimize the site with a demand charge.  </p> <p>This demand charge has a minimum of 40 MW, and a rate of 200 $/MWh:</p> <pre><code>demand_charge_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n            {\n                \"function\": \"max_many_variables\",\n                \"variables\": {\n                    \"asset_type\": \"site\",\n                    \"variable\": \"import_power_mwh\",\n                },\n                \"constant\": 40,\n                \"coefficient\": 200,\n                \"M\": max(electric_load_mwh) * 10\n            },\n        ]\n    },\n)\n</code></pre> <p>Now we see that the CHP generator has generated in the one interval that had a demand higher than our demand charge minimum of 40:</p> <pre><code>print(\n    demand_charge_simulation.results[\n        [\"site-electric_load_mwh\", \"chp-electric_generation_mwh\"]\n    ]\n)\n</code></pre> <pre><code>   site-electric_load_mwh  chp-electric_generation_mwh\n0                    30.0                          0.0\n1                    50.0                         10.0\n2                    10.0                          0.0\n</code></pre> <p>If we re-run this simulation with a lower demand charge minimum, our CHP generator is now incentivized to generate in other intervals:</p> <pre><code>demand_charge_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n            {\n                \"function\": \"max_many_variables\",\n                \"variables\": {\n                    \"asset_type\": \"site\",\n                    \"variable\": \"import_power_mwh\",\n                },\n                \"constant\": 20,\n                \"coefficient\": 200,\n                \"M\": max(electric_load_mwh) * 10,\n            },\n        ]\n    },\n)\n\nprint(\n    demand_charge_simulation.results[\n        [\"site-electric_load_mwh\", \"chp-electric_generation_mwh\"]\n    ]\n)\n</code></pre> <pre><code>   site-electric_load_mwh  chp-electric_generation_mwh\n0                    30.0                         10.0\n1                    50.0                         30.0\n2                    10.0                          0.0\n</code></pre>"},{"location":"how-to/complex-terms/#minimum-export-incentive","title":"Minimum Export Incentive","text":"<p>Above we looked at a function term that took the maximum across many linear program variables at once using the <code>max_many_variables</code> function term, which results in one term being added to the objective function.</p> <p>Another type of function term included in <code>energypylinear</code> is the <code>min_two_variables</code> function term, which adds one term to the objective function for each interval in the linear program. </p> <p>The term will represent the minimum of either a linear program variable and another linear program variable, or a linear program variable and a user supplied constant.</p> <p>To demonstrate this we can look at a site where we want to incentivize a minimum export of 15 MWh or greater in each interval.  The site will receive the maximum benefit when exporting 15 MW or more, and less benefit when exporting less than 15 MWh. There is no incentive to export more than 15 MWh.</p> <p>Let's first setup a site with a CHP system:</p> <pre><code>import energypylinear as epl\n\nelectric_load_mwh = [30.0, 50.0, 10.0]\nelectricity_prices = [0.0, 0.0, 0.0]\ngas_prices = 20\n\nsite = epl.Site(\n    assets=[\n        epl.CHP(\n            electric_efficiency_pct=1.0,\n            electric_power_max_mw=50,\n            electric_power_min_mw=0,\n        )\n    ],\n    gas_prices=gas_prices,\n    electricity_prices=electricity_prices,\n    electric_load_mwh=electric_load_mwh,\n)\n</code></pre> <p>Let's optimize the site without a minimum export incentive:</p> <pre><code>no_export_incentive_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n        ]\n    },\n)\n\nprint(no_export_incentive_simulation.results['chp-electric_generation_mwh'])\n</code></pre> <p>As expected, our CHP system doesn't generate:</p> <pre><code>0    0.0\n1    0.0\n2    0.0\nName: chp-electric_generation_mwh, dtype: float64\n</code></pre> <p>Let's now add a minimum export incentive using the <code>min_two_variables</code> function term:</p> <pre><code>no_export_incentive_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n            {\n                \"function\": \"min_two_variables\",\n                \"a\": {\n                    \"asset_type\": \"site\",\n                    \"variable\": \"export_power_mwh\",\n                },\n                \"b\": 15,\n                \"coefficient\": -200,\n                \"M\": max(electric_load_mwh) * 10\n            },\n        ]\n    },\n)\n\nprint(\n    no_export_incentive_simulation.results[\n        [\n            \"site-electric_load_mwh\",\n            \"site-export_power_mwh\",\n            \"chp-electric_generation_mwh\",\n        ]\n    ]\n)\n</code></pre> <p>As expected, our CHP system generates to export a minimum of 15 MWh where possible:</p> <pre><code>   site-electric_load_mwh  site-export_power_mwh  chp-electric_generation_mwh\n0                    30.0                   15.0                         45.0\n1                    50.0                    0.0                          0.0\n2                    10.0                   15.0                         25.0\n</code></pre> <p>Our asset does not generate in the second interval because the site demand is too high to allow the asset to export any electricity.</p>"},{"location":"how-to/custom-constraints/","title":"Constraints","text":"<p>Constraints define the feasible region of a linear program.  They are how you control what is and isn't possible in a simulation.</p> <p>The assets and site in <code>energypylinear</code> apply built-in constraints to the linear program. In addition, you can define your own custom constraints.</p> <p>A custom constraint allows you to control what can and cannot happen in an <code>energypylinear</code> simulation.</p>"},{"location":"how-to/custom-constraints/#custom-constraint","title":"Custom Constraint","text":"<p>The <code>epl.Constraint</code> represents a single custom constraint.</p> <p>A custom constraint has a left hand side, a right hand side and a sense.</p> <pre><code>class Constraint(pydantic.BaseModel):\n    \"\"\"A custom constraint.\n\n    Made of a left-hand side (LHS), a right-hand side (RHS) and a sense (&lt;=, ==, &gt;=).\n\n    Attributes:\n        lhs: The left-hand side of the constraint.\n        rhs: The right-hand side of the constraint.\n        sense: The constraint sense and a sense (&lt;=, ==, &gt;=).\n        interval_aggregation: How to aggregate terms across intervals.\n            None will result in one constraint per interval.\n            \"sum\" will result in one constraint per simulation.\n\n    Example of a custom constraint with the `energypylinear` Pydantic models to represent:\n    - the constraint,\n    - the constraint terms on the left and right sides,\n    - the sense of the constraint,\n    - whether to aggregate across the interval (time) dimension.\n\n    ```python\n    import energypylinear as epl\n\n    epl.Battery(\n        power_mw=1,\n        capacity_mwh=2,\n        efficiency_pct=0.98,\n        electricity_prices=np.random.normal(0.0, 1000, 48 * 7),\n        constraints=[\n            epl.Constraint(\n                lhs=[\n                    epl.ConstraintTerm(\n                        asset_type=\"battery\", variable=\"electric_charge_mwh\"\n                    ),\n                    epl.ConstraintTerm(\n                        asset_type=\"battery\", variable=\"electric_discharge_mwh\"\n                    ),\n                ],\n                rhs=cycle_limit_mwh,\n                sense=\"le\",\n                interval_aggregation=\"sum\",\n            )\n        ],\n    )\n    ```\n\n    Constraints can also be set with dictionaries:\n\n    ```python\n    import energypylinear as epl\n\n    epl.Battery(\n        power_mw=1,\n        capacity_mwh=2,\n        efficiency_pct=0.98,\n        electricity_prices=np.random.normal(0.0, 1000, 48 * 7),\n        constraints=[\n            {\n                \"lhs\": [\n                    {\"asset_type\": \"battery\", \"variable\": \"electric_charge_mwh\"},\n                    {\"asset_type\": \"battery\", \"variable\": \"electric_discharge_mwh\"},\n                ],\n                \"rhs\": cycle_limit_mwh,\n                \"sense\": \"le\",\n                \"interval_aggregation\": \"sum\",\n            },\n        ],\n    )\n    \"\"\"\n\n    lhs: float | ConstraintTerm | dict | list[float | ConstraintTerm | dict]\n    rhs: float | ConstraintTerm | dict | list[float | ConstraintTerm | dict]\n    sense: typing.Literal[\"le\", \"eq\", \"ge\"]\n    interval_aggregation: typing.Literal[\"sum\"] | None = None\n</code></pre> <p>It also has an option for configuring how the constraint is aggregated over the simulation intervals.</p>"},{"location":"how-to/custom-constraints/#constraint-terms","title":"Constraint Terms","text":"<p>Both the left and right hand sides of a custom constraint are lists of constraint terms. A constraint term can be either a constant, an <code>epl.ConstraintTerm</code> or a dictionary.</p> <p>The <code>epl.ConstraintTerm</code> represents a single term in a constraint:</p> <pre><code>@dataclasses.dataclass\nclass ConstraintTerm:\n    \"\"\"A term in a constraint.\n\n    The sum of terms creates the two sides of a constraint,\n    the left-hand side (LHS) and right-hand side (RHS).\n\n    Examples:\n\n    ```python\n    # site import power electricity cost\n    ConstraintTerm(\n        variable=\"import_power_mwh\",\n        asset_type=\"site\",\n        interval_data=\"electricity_prices\"\n    )\n\n    # site export power electricity revenue\n    ConstraintTerm(\n        variable=\"import_power_mwh\",\n        asset_type=\"site\",\n        interval_data=\"electricity_prices\",\n        coefficient=-1\n    )\n\n    # battery cycle cost\n    ConstraintTerm(\n        variable=\"electric_charge_mwh\",\n        asset_type=\"battery\",\n        coefficient=0.25\n    )\n    ```\n\n    Attributes:\n        variable: The linear program variable.  This will be an\n            attribute of a OneInterval object, like `import_power_mwh`\n            or `gas_consumption_mwh`.\n        asset_type: The type of asset, such as `battery` or `chp`.\n            `*` will include all assets.\n        interval_data: The interval data variable, such as\n            `electricity_prices` or `gas_prices`.\n        asset_name: The name of a specific asset.\n        coefficient: A constant multipler for the term.\n    \"\"\"\n\n    variable: str\n    asset_type: str | None = None\n    interval_data: str | None = None\n    asset_name: str | None = None\n    coefficient: float = 1.0\n</code></pre>"},{"location":"how-to/custom-constraints/#examples","title":"Examples","text":""},{"location":"how-to/custom-constraints/#limiting-battery-cycles","title":"Limiting Battery Cycles","text":"<p>The example below shows how to optimize a battery with a custom constraint on battery cycles.</p> <p>We define battery cycles as the sum of the total battery charge and discharge, and constrain it to be less than or equal to 15 cycles of 2 MWh per cycle:</p> <pre><code>import energypylinear as epl\nimport numpy as np\n\nnp.random.seed(42)\ncycle_limit_mwh = 30\nasset = epl.Battery(\n    power_mw=1,\n    capacity_mwh=2,\n    efficiency_pct=0.98,\n    electricity_prices=np.random.normal(0.0, 1000, 48 * 7),\n    constraints=[\n        epl.Constraint(\n            lhs=[\n                epl.ConstraintTerm(\n                    asset_type=\"battery\", variable=\"electric_charge_mwh\"\n                ),\n                epl.ConstraintTerm(\n                    asset_type=\"battery\", variable=\"electric_discharge_mwh\"\n                ),\n            ],\n            rhs=cycle_limit_mwh,\n            sense=\"le\",\n            interval_aggregation=\"sum\",\n        )\n    ],\n)\nsimulation = asset.optimize(verbose=3)\ntotal_cycles = simulation.results.sum()[\n    [\"battery-electric_charge_mwh\", \"battery-electric_discharge_mwh\"]\n].sum()\nprint(f\"{total_cycles=}\")\n</code></pre> <p>After simulation we can see our total cycles are constrained to an upper limit of 30 (with a small floating point error):</p> <pre><code>total_cycles=30.000000002\n</code></pre>"},{"location":"how-to/custom-constraints/#constraining-total-generation","title":"Constraining Total Generation","text":"<p>The example below shows how to use a custom constraint to constrain the total generation in a site.</p> <p>We define a site with a solar and electric generator asset, with the available solar power increasing with time:</p> <pre><code>import energypylinear as epl\nimport numpy as np\n\nnp.random.seed(42)\n\nidx_len = 4\ngenerator_size = 100\nsolar_gen = [10.0, 20, 30, 40]\nsite = epl.Site(\n    assets=[\n        epl.RenewableGenerator(\n            electric_generation_mwh=solar_gen,\n            name=\"solar\",\n            electric_generation_lower_bound_pct=0.0,\n        ),\n        epl.CHP(electric_power_max_mw=generator_size, electric_efficiency_pct=0.5),\n    ],\n    electricity_prices=np.full(idx_len, 400),\n    gas_prices=10,\n    constraints=[\n        {\n            \"lhs\": {\"variable\": \"electric_generation_mwh\", \"asset_type\": \"*\"},\n            \"rhs\": 25,\n            \"sense\": \"le\",\n        }\n    ],\n)\nsimulation = site.optimize(verbose=3)\nprint(\n    simulation.results[\n        [\n            \"chp-electric_generation_mwh\",\n            \"solar-electric_generation_mwh\",\n            \"total-electric_generation_mwh\",\n        ]\n    ]\n)\n</code></pre> <p>As solar generation becomes available, the CHP electric generation decreases to keep the total site electric generation at 25 MWh:</p> <pre><code>   chp-electric_generation_mwh  solar-electric_generation_mwh  total-electric_generation_mwh\n0                         15.0                           10.0                           25.0\n1                          5.0                           20.0                           25.0\n2                          0.0                           25.0                           25.0\n3                          0.0                           25.0                           25.0\n</code></pre>"},{"location":"how-to/custom-interval-data/","title":"Interval Data","text":"<p>Interval data is a key input to an <code>energypylinear</code> simulation.</p> <p>By default, <code>energypylinear</code> accepts interval data for things like electricity prices, carbon intensities and site electricity and heat consumption:</p> <pre><code>class Site:\n    \"\"\"\n    The Site asset can optimize many assets together in a single linear program.\n\n    All assets are connected to the same site electricity, high and low temperature networks.\n    \"\"\"\n\n    def __init__(\n        self,\n        assets: list,\n        electricity_prices: np.ndarray | list[float] | float | None = None,\n        export_electricity_prices: np.ndarray | list[float] | float | None = None,\n        electricity_carbon_intensities: np.ndarray | list[float] | float | None = None,\n        gas_prices: np.ndarray | list[float] | float | None = None,\n        electric_load_mwh: np.ndarray | list[float] | float | None = None,\n        high_temperature_load_mwh: np.ndarray | list[float] | float | None = None,\n        low_temperature_load_mwh: np.ndarray | list[float] | float | None = None,\n        low_temperature_generation_mwh: np.ndarray | list[float] | float | None = None,\n        name: typing.Literal[\"site\"] = \"site\",\n        freq_mins: int = defaults.freq_mins,\n        import_limit_mw: float = 10000,\n        export_limit_mw: float = 10000,\n        constraints: \"list[epl.Constraint] | list[dict] | None\" = None,\n        **kwargs: typing.Any,\n    ):\n        \"\"\"\n        Initialize a Site.\n\n        Args:\n            assets: Assets to optimize together.\n            electricity_prices: The price of import electricity in each interval.\n                Will define both import and export prices if `export_electricity_prices` is None.\n            export_electricity_prices: The price of export electricity in each interval.\n            electricity_carbon_intensities: Carbon intensity of electricity in each interval.\n            electric_load_mwh: Electricity demand consumed by the site.\n            gas_prices: Price of natural gas, used in CHP and boilers in each interval.\n            high_temperature_load_mwh: High temperature load of the site.\n            low_temperature_load_mwh: Low temperature load of the site.\n            name: The site name.\n            freq_mins: Size of an interval in minutes.\n            import_limit_mw: Maximum import power of the site.\n            export_limit_mw: Minimum import power of the site.\n            constraints: Additional custom constraints to apply to the linear program.\n            kwargs: Keyword arguments attempted to be used as extra interval data.\n        \"\"\"\n</code></pre> <p>These arguments are passed to the <code>SiteIntervalData</code> object, which is responsible for managing interval data for a site:</p> <pre><code>import energypylinear as epl\n\nasset = epl.Battery(electricity_prices=[100, 50, 200])\nprint(asset.site.cfg.interval_data)\n</code></pre> <pre><code>electricity_prices=array([100.,  50., 200.]) export_electricity_prices=array([100.,  50., 200.]) electricity_carbon_intensities=array([0.1, 0.1, 0.1]) gas_prices=array([20, 20, 20]) electric_load_mwh=array([0, 0, 0]) high_temperature_load_mwh=array([0, 0, 0]) low_temperature_load_mwh=array([0, 0, 0]) low_temperature_generation_mwh=array([0, 0, 0]) idx=array([0, 1, 2])\n</code></pre>"},{"location":"how-to/custom-interval-data/#custom-interval-data","title":"Custom Interval Data","text":"<p>Often you will want to use different interval data for your simulation - for example modelling site network charges.</p> <p>Additional keyword arguments passed into a site or asset <code>__init__</code> are attempted to be parsed into interval data. These will be parsed into site interval data, even if passed into an asset.</p> <p>For example, when we pass in a <code>network_charge</code> argument, we end up with a <code>network_charge</code> attribute on our <code>asset.site.cfg.interval_data</code> object:</p> <pre><code>import energypylinear as epl\n\nelectricity_prices = [100, 50, 200]\nasset = epl.Battery(electricity_prices=[100, 50, 200], network_charges=[10, 20, 30])\nprint(asset.site.cfg.interval_data)\n</code></pre> <pre><code>electricity_prices=array([100.,  50., 200.]) export_electricity_prices=array([100.,  50., 200.]) electricity_carbon_intensities=array([0.1, 0.1, 0.1]) gas_prices=array([20, 20, 20]) electric_load_mwh=array([0, 0, 0]) high_temperature_load_mwh=array([0, 0, 0]) low_temperature_load_mwh=array([0, 0, 0]) low_temperature_generation_mwh=array([0, 0, 0]) idx=array([0, 1, 2]) network_charges=array([10., 20., 30.])\n</code></pre>"},{"location":"how-to/custom-interval-data/#custom-interval-data-in-simulation-results","title":"Custom Interval Data in Simulation Results","text":"<p>All custom interval data will appear in the simulation results:</p> <pre><code>import energypylinear as epl\n\nasset = epl.Battery(electricity_prices=[100, 50, 200], network_charges=[10, 20, 30])\nsimulation = asset.optimize(verbose=3)\nprint(simulation.results[\"site-network_charges\"])\n</code></pre> <pre><code>0    10.0\n1    20.0\n2    30.0\nName: site-network_charges, dtype: float64\n</code></pre>"},{"location":"how-to/custom-interval-data/#custom-interval-data-in-custom-objective-functions","title":"Custom Interval Data in Custom Objective Functions","text":"<p>Custom interval data can be used in a custom objective function:</p> <pre><code>import energypylinear as epl\n\nasset = epl.Battery(electricity_prices=[100, 50, 200], network_charges=[10, 20, 30])\nsimulation = asset.optimize(\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n        ]\n    },\n    verbose=3\n)\n</code></pre>"},{"location":"how-to/custom-objectives/","title":"Objective Functions","text":"<p>Objective functions define the incentives and costs in a linear program. They are how you control what the linear program maximizes or minimizes in your simulation.</p> <p><code>energypylinear</code> has two different objective functions (price or carbon) built into the library.  These are available as argument to <code>.optimize()</code> on an asset or site:</p> <pre><code>import energypylinear as epl\n\nbattery = epl.Battery(electricity_prices=[100, 50, 200])\nsimulation = battery.optimize(\n    objective=\"carbon\",\n    verbose=3\n)\n</code></pre> <p>In addition, <code>energypylinear</code> allows you to define your own objective functions.</p> <p>A custom objective function allows you to optimize for the revenues and costs that are important to you.</p>"},{"location":"how-to/custom-objectives/#custom-objective-function","title":"Custom Objective Function","text":"<p>A custom objective function is a list of terms:</p> <pre><code>OneTerm = Term | FunctionTermTwoVariables | FunctionTermManyVariables\n\n\n@dataclasses.dataclass\nclass CustomObjectiveFunction:\n    \"\"\"A custom objective function - a sum of `OneTerm` objects.\n\n    Example of a custom objective function with the `energypylinear` Pydantic models to represent:\n    - site import power cost,\n    - site export power cost.\n\n    ```python\n    import energypylinear as epl\n\n    asset = epl.Battery(\n        power_mw=1,\n        capacity_mwh=2,\n        efficiency_pct=0.98,\n        electricity_prices=np.random.normal(0.0, 1000, 48 * 7)\n        )\n\n    asset.optimize(\n        objective={\"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            }\n        ]}\n    )\n    ```\n\n    Objectives can also be set with dictionaries:\n\n    ```python\n    import energypylinear as epl\n\n    epl.Battery(\n        power_mw=1,\n        capacity_mwh=2,\n        efficiency_pct=0.98,\n        electricity_prices=np.random.normal(0.0, 1000, 48 * 7),\n    )\n\n    site.optimize(\n        objective=epl.CustomObjectiveFunction(\n            terms=[\n                epl.Term(\n                    asset_type=\"site\",\n                    variable=\"import_power_mwh\",\n                    interval_data=\"electricity_prices\",\n                ),\n                epl.Term(\n                    asset_type=\"site\",\n                    variable=\"export_power_mwh\",\n                    interval_data=\"electricity_prices\",\n                    coefficient=-1,\n                ),\n                epl.Term(\n                    asset_name=\"solar\",\n                    variable=\"electric_generation_mwh\",\n                    coefficient=-25,\n                ),\n            ]\n        )\n    )\n    ```\n    \"\"\"\n\n    terms: list[OneTerm]\n</code></pre> <p>The objective function used in the linear program is the sum of these terms. They can be supplied as either a <code>epl.Term</code> and <code>epl.CustomObjectiveFunction</code> object or as a dictionaries.</p> <p>If supplied as dictionary, the term will be coerced to an <code>epl.Term</code>.</p>"},{"location":"how-to/custom-objectives/#simple-terms","title":"Simple Terms","text":"<p>Core to the custom objective function is the <code>epl.Term</code>, which represents a single term in the objective function:</p> <pre><code>import dataclasses\n\n@dataclasses.dataclass\nclass Term:\n    \"\"\"\n    A simple term in the objective function.\n\n    Will add `i` terms to the objective function, where `i` is\n    the number of intervals in the simulation.\n\n    This term will be represented in the objective function as:\n\n    ```pseudocode\n    objective = []\n    for i in interval_data.idx:\n        term = variable * interval_data[i] * coefficient\n        objective.append(term)\n    ```\n\n    Examples:\n    ```python\n    # an objective function term for site import power electricity cost\n    Term(\n        variable=\"import_power_mwh\",\n        asset_type=\"site\",\n        interval_data=\"electricity_prices\"\n    )\n\n    # an objective function term for site export power electricity revenue\n    Term(\n        variable=\"import_power_mwh\",\n        asset_type=\"site\",\n        interval_data=\"electricity_prices\",\n        coefficient=-1\n    )\n\n    # an objective function term for battery cycle cost\n    Term(\n        variable=\"electric_charge_mwh\",\n        asset_type=\"battery\",\n        coefficient=0.25\n    )\n\n    ```\n\n    Attributes:\n        variable: The linear program variable.  This will be an\n            attribute of a OneInterval object, like `import_power_mwh`\n            or `gas_consumption_mwh`.\n        asset_type: The type of asset, such as `battery` or `chp`.\n            `*` will include all assets.\n        interval_data: The interval data variable, such as\n            `electricity_prices` or `gas_prices`.\n        asset_name: The name of a specific asset.\n        coefficient: A constant multipler for the term.\n        type: The type of the term.\n    \"\"\"\n\n    variable: str\n    asset_type: str | None = None\n    interval_data: str | None = None\n    asset_name: str | None = None\n    coefficient: float = 1.0\n    type: typing.Literal[\"simple\"] = \"simple\"\n</code></pre> <p>A term can target either many assets by type or one asset by name. It can also include multiplication by interval data or by a coefficient.</p>"},{"location":"how-to/custom-objectives/#examples","title":"Examples","text":""},{"location":"how-to/custom-objectives/#simultaneous-price-and-carbon-optimization","title":"Simultaneous Price and Carbon Optimization","text":"<p><code>energypylinear</code> has two different objective functions (price or carbon) built into the library - these optimize for either price or carbon, but not both at the same time.</p> <p>This example shows how to optimize a battery for an objective that will optimize for both profit and emissions at the same time.</p> <p>Below we create an objective function where we:</p> <ul> <li>reduce import when the electricity price or carbon intensity is high,</li> <li>increase export when the electricity price or carbon intensity is low.</li> </ul> <p>Key to this is defining a carbon price, which allows us to convert our emissions into money:</p> <pre><code>import numpy as np\nimport energypylinear as epl\n\ndef simulate(\n    carbon_price: int, seed: int, n: int, verbose: int = 3\n) -&gt; epl.SimulationResult:\n    \"\"\"Run a battery simulation with a custom objective function.\"\"\"\n    np.random.seed(seed)\n    site = epl.Site(\n        assets=[epl.Battery(power_mw=10, capacity_mwh=20)],\n        electricity_prices=np.random.normal(100, 1000, n),\n        electricity_carbon_intensities=np.clip(\n            np.random.normal(1, 10, n), a_min=0, a_max=None\n        ),\n    )\n    return site.optimize(\n        objective=epl.CustomObjectiveFunction(\n            terms=[\n                epl.Term(\n                    asset_type=\"site\",\n                    variable=\"import_power_mwh\",\n                    interval_data=\"electricity_prices\",\n                ),\n                epl.Term(\n                    asset_type=\"site\",\n                    variable=\"export_power_mwh\",\n                    interval_data=\"electricity_prices\",\n                    coefficient=-1,\n                ),\n                epl.Term(\n                    asset_type=\"site\",\n                    variable=\"import_power_mwh\",\n                    interval_data=\"electricity_carbon_intensities\",\n                    coefficient=carbon_price,\n                ),\n                epl.Term(\n                    asset_type=\"site\",\n                    variable=\"export_power_mwh\",\n                    interval_data=\"electricity_carbon_intensities\",\n                    coefficient=-1 * carbon_price,\n                ),\n            ]\n        ),\n        verbose=verbose,\n    )\n\nprint(simulate(carbon_price=50, seed=42, n=72))\n</code></pre> <pre><code>&lt;energypylinear.SimulationResult feasible:True, rows:72, cols:29&gt;\n</code></pre> <p>We can validate that our custom objective function is working as expected by running simulations across many carbon prices:</p> <pre><code>import pandas as pd\nfrom rich import print\n\nresults = []\nfor carbon_price in range(0, 300, 50):\n    simulation = simulate(carbon_price=carbon_price, seed=42, n=72, verbose=3)\n    accounts = epl.get_accounts(simulation.results)\n    results.append(\n        {\n            \"carbon_price\": carbon_price,\n            \"profit\": f\"{accounts.profit:5.2f}\",\n            \"emissions\": f\"{accounts.emissions:3.2f}\",\n        }\n    )\nprint(pd.DataFrame(results))\n</code></pre> <pre><code>   carbon_price     profit emissions\n0             0  466212.61    161.16\n1            50  452318.68   -579.51\n2           100  390152.38  -1403.21\n3           150  336073.24  -1848.94\n4           200  290186.26  -2098.28\n5           250  248371.70  -2288.42\n</code></pre> <p>As expected as our carbon price increases, both our profit and emissions decrease.</p>"},{"location":"how-to/custom-objectives/#renewables-certificates","title":"Renewables Certificates","text":"<p>In the previous example we used a custom objective function to apply incentives to the site import and export electricity by its asset type.</p> <p>A custom objective function can also be used to apply incentives to a single asset by name.</p> <p>An example of this is a renewable energy certificate scheme, where the generation from one asset receives additional income for each MWh generated.</p> <p>In the example below, our <code>solar</code> asset receives additional income for each MWh generated.</p> <p>The site has a constrained export limit, which limits how much both generators can output. The site electric load increases in each interval, which allows us to see which generator is called first:</p> <pre><code>import energypylinear as epl\n\nassets = [\n    epl.RenewableGenerator(\n        electric_generation_mwh=50,\n        name=\"wind\",\n        electric_generation_lower_bound_pct=0.0,\n    ),\n    epl.RenewableGenerator(\n        electric_generation_mwh=50,\n        name=\"solar\",\n        electric_generation_lower_bound_pct=0.0,\n    ),\n]\nsite = epl.Site(\n    assets=assets,\n    electricity_prices=[250, 250, 250, 250, 250],\n    export_limit_mw=25,\n    electric_load_mwh=[0, 50, 75, 100, 300],\n)\nsimulation = site.optimize(\n    verbose=3,\n    objective=epl.CustomObjectiveFunction(\n        terms=[\n            epl.Term(\n                asset_type=\"site\",\n                variable=\"import_power_mwh\",\n                interval_data=\"electricity_prices\",\n            ),\n            epl.Term(\n                asset_type=\"site\",\n                variable=\"export_power_mwh\",\n                interval_data=\"electricity_prices\",\n                coefficient=-1,\n            ),\n            epl.Term(\n                asset_name=\"solar\",\n                variable=\"electric_generation_mwh\",\n                coefficient=-25,\n            ),\n        ]\n    ),\n)\nprint(\n    simulation.results[\n        [\"solar-electric_generation_mwh\", \"wind-electric_generation_mwh\"]\n    ]\n)\n</code></pre> <pre><code>   solar-electric_generation_mwh  wind-electric_generation_mwh\n0                           25.0                           0.0\n1                           50.0                          25.0\n2                           50.0                          50.0\n3                           50.0                          50.0\n4                           50.0                          50.0\n</code></pre> <p>As expected, the first generator that is called is the <code>solar</code> generator, as it receives additional income for it's output.</p> <p>As the site demand increases, the <code>wind</code> generator is called to make up the remaining demand.</p>"},{"location":"how-to/custom-objectives/#synthetic-ppa","title":"Synthetic PPA","text":"<p>A synthetic PPA is a financial instrument that allows swapping of the output of a wholesale exposed generator to a fixed price.</p> <p>This can be modelled as a custom objective function.</p> <p>In the example below, we model a site with wholesale exposed import and export, and swap the output of our <code>wind</code> generator from the wholesale to a fixed price:</p> <pre><code>import numpy as np\nimport energypylinear as epl\n\nnp.random.seed(42)\nn = 6\nwind_mwh = np.random.uniform(0, 100, n)\nelectricity_prices = np.random.normal(0, 1000, n)\n\nassets = [\n    epl.RenewableGenerator(\n        electric_generation_mwh=wind_mwh,\n        name=\"wind\",\n        electric_generation_lower_bound_pct=0.0,\n    ),\n    epl.Battery(power_mw=20, capacity_mwh=20),\n]\nsite = epl.Site(assets=assets, electricity_prices=electricity_prices)\nterms = [\n    {\n        \"asset_type\": \"site\",\n        \"variable\": \"import_power_mwh\",\n        \"interval_data\": \"electricity_prices\",\n    },\n    {\n        \"asset_type\": \"site\",\n        \"variable\": \"export_power_mwh\",\n        \"interval_data\": \"electricity_prices\",\n        \"coefficient\": -1,\n    },\n    {\n        \"asset_name\": \"wind\",\n        \"variable\": \"electric_generation_mwh\",\n        \"interval_data\": \"electricity_prices\",\n        \"coefficient\": 1,\n    },\n    {\n        \"asset_name\": \"wind\",\n        \"variable\": \"electric_generation_mwh\",\n        \"coefficient\": -70\n    },\n]\nsimulation = site.optimize(\n    verbose=4,\n    objective={\"terms\": terms},\n)\nprint(simulation.results[[\"site-electricity_prices\", \"wind-electric_generation_mwh\"]])\n</code></pre> <pre><code>   site-electricity_prices  wind-electric_generation_mwh\n0              1579.212816                     37.454012\n1               767.434729                     95.071431\n2              -469.474386                     73.199394\n3               542.560044                     59.865848\n4              -463.417693                     15.601864\n5              -465.729754                     15.599452\n</code></pre> <p>As expected, our renewable generator still generates even during times of negative electricity prices - this is because its output is incentivized at a fixed, positive price.</p>"},{"location":"how-to/custom-objectives/#battery-cycle-cost","title":"Battery Cycle Cost","text":"<p>It's common in battery optimization to include a cost to use the battery - for every MWh of charge, some cost is incurred.</p> <p>We can model this cost using a custom objective function, by applying a cost to discharging the battery:</p> <pre><code>import numpy as np\nimport energypylinear as epl\n\nnp.random.seed(42)\nelectricity_prices = np.random.normal(0, 1000, 48)\n\nassets = [epl.Battery(power_mw=20, capacity_mwh=20)]\nsite = epl.Site(assets=assets, electricity_prices=electricity_prices)\nterms = [\n    {\n        \"asset_type\": \"site\",\n        \"variable\": \"import_power_mwh\",\n        \"interval_data\": \"electricity_prices\",\n    },\n    {\n        \"asset_type\": \"site\",\n        \"variable\": \"export_power_mwh\",\n        \"interval_data\": \"electricity_prices\",\n        \"coefficient\": -1,\n    },\n    {\n        \"asset_type\": \"battery\",\n        \"variable\": \"electric_discharge_mwh\",\n        \"coefficient\": 0.25\n    }\n]\nsite.optimize(verbose=4, objective={\"terms\": terms})\n</code></pre> <p>You could also apply this cost to the battery electric charge, or to both the charge and discharge at the same time:</p> <pre><code>terms = [\n    {\n        \"asset_type\": \"battery\",\n        \"variable\": \"electric_charge_mwh\",\n        \"coefficient\": 0.25\n    },\n    {\n        \"asset_type\": \"battery\",\n        \"variable\": \"electric_discharge_mwh\",\n        \"coefficient\": 0.25\n    }\n]\n</code></pre> <p>We can validate that this works by applying a stronger cycle cost and seeing the battery use decrease:</p> <pre><code>import pandas as pd\n\nresults = []\nfor cycle_cost in [0.25, 0.5, 1.0, 2.0]:\n    terms = [\n        {\n            \"asset_type\": \"site\",\n            \"variable\": \"import_power_mwh\",\n            \"interval_data\": \"electricity_prices\",\n        },\n        {\n            \"asset_type\": \"site\",\n            \"variable\": \"export_power_mwh\",\n            \"interval_data\": \"electricity_prices\",\n            \"coefficient\": -1,\n        },\n        {\n            \"asset_type\": \"battery\",\n            \"variable\": \"electric_discharge_mwh\",\n            \"interval_data\": \"electricity_prices\",\n            \"coefficient\": cycle_cost,\n        },\n    ]\n    simulation = site.optimize(verbose=4, objective={\"terms\": terms})\n    results.append(\n        {\n            \"cycle_cost\": cycle_cost,\n            \"battery-electric_discharge_mwh\": simulation.results[\n                \"battery-electric_discharge_mwh\"\n            ].sum(),\n        }\n    )\nprint(pd.DataFrame(results))\n</code></pre> <pre><code>   cycle_cost  battery-electric_discharge_mwh\n0        0.25                           306.0\n1        0.50                           322.0\n2        1.00                           338.0\n3        2.00                           264.0\n</code></pre> <p>As expected, as our cycle cost increases, our battery usage decreases.</p>"},{"location":"how-to/custom-objectives/#complex-terms","title":"Complex Terms","text":"<p>In <code>energypylinear</code> you can use custom objective functions to define a custom set of incentives and costs in your linear program.</p> <p>The objective function will often be made up of simple terms, which are the product of a single linear variable (one per interval), interval data and a coefficient. </p> <p>Sites will however often have more complicated costs and revenues, that involve taking the minimum or maximum of a collection of variables.</p> <p>A complex custom objective term allows you to construct an objective function with a complex set of costs and revenues.</p> <p><code>energypylinear</code> uses complex terms to include these more complicated incentives and costs in the objective function:</p> <pre><code>@dataclasses.dataclass\nclass FunctionTermTwoVariables:\n    \"\"\"A function term for constraining two variables.\n\n    Will add `i` terms to the objective function, where `i` is\n    the number of intervals in the simulation.\n\n    Will also add constraints to the linear program.\n\n    Attributes:\n        function: The function to apply to the two variables.\n        a: Left hand side variable.\n        b: Right hand side variable.\n        M: Big-M constant used in the constraints.\n        interval_data: The interval data variable, such as\n            `electricity_prices` or `gas_prices`.\n        coefficient: A constant multipler for the term.\n        type: The type of the term.\n    \"\"\"\n\n    function: typing.Literal[\"max_two_variables\", \"min_two_variables\"]\n    a: Term | float\n    b: Term | float\n    M: float\n    interval_data: str | None = None\n    coefficient: float = 1.0\n    type: typing.Literal[\"complex\"] = \"complex\"\n\n\n@dataclasses.dataclass\nclass FunctionTermManyVariables:\n    \"\"\"A function term for constraining many variables.\n\n    This will add 1 term to the objective function.\n\n    Will also add constraints to the linear program.\n\n    Attributes:\n        function: Function to apply to the many variables.\n        variables: Linear program variables to apply the function over.\n        M: Big-M constant used in the constraints.\n        interval_data: The interval data variable, such as\n            `electricity_prices` or `gas_prices`.\n        constant: A constant to include in the function alongside\n            the linear program variables.\n        coefficient: A constant multipler for the term.\n        type: The type of the term.\n    \"\"\"\n\n    function: typing.Literal[\"max_many_variables\", \"min_many_variables\"]\n    variables: Term\n    M: float\n    constant: float = 0.0\n    coefficient: float = 1.0\n    type: typing.Literal[\"complex\"] = \"complex\"\n</code></pre> <p>Currently the library includes four complex terms, which allow adding minimum or maximum constraints on collections of linear program variables and floats:</p> Function Number of Linear Variables Number of Floats Terms Added to Objective Function <code>min_two_variables</code> 1 or 2 0 or 1 Interval index length <code>max_two_variables</code> 1 or 2 0 or 1 Interval index length <code>max_many_variables</code> Interval index length 0 or 1 1 <code>min_many_variables</code> Interval index length 0 or 1 1"},{"location":"how-to/custom-objectives/#examples_1","title":"Examples","text":""},{"location":"how-to/custom-objectives/#maximum-demand-charge","title":"Maximum Demand Charge","text":"<p>A common incentive for many sites is a maximum demand charge, where a site will incur a cost based on the maximum site import over a length of time (commonly a month).</p> <p>We can model this using the <code>max_many_variables</code> function term, which will add a single term to the objective function that is the maximum of many linear program variables and a user supplied constant.</p> <p>We can demonstrate this by using an example of a site with a variable electric load, with a peak of 50 MW.</p> <p>We can first optimize the site with an objective function that does not include a demand charge:</p> <pre><code>import energypylinear as epl\n\nelectric_load_mwh = [30.0, 50.0, 10.0]\nelectricity_prices = [0.0, 0.0, 0.0]\ngas_prices = 20\n\nsite = epl.Site(\n    assets=[\n        epl.CHP(\n            electric_efficiency_pct=1.0,\n            electric_power_max_mw=50,\n            electric_power_min_mw=0,\n        )\n    ],\n    gas_prices=gas_prices,\n    electricity_prices=electricity_prices,\n    electric_load_mwh=electric_load_mwh,\n)\n\nno_demand_charge_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n        ]\n    },\n)\n</code></pre> <p>As expected for a site with low electricity prices, this CHP does not generate electricity in any interval:</p> <pre><code>print(no_demand_charge_simulation.results['chp-electric_generation_mwh'])\n</code></pre> <pre><code>0    0.0\n1    0.0\n2    0.0\nName: chp-electric_generation_mwh, dtype: float64\n</code></pre> <p>Let's now optimize the site with a demand charge.  </p> <p>This demand charge has a minimum of 40 MW, and a rate of 200 $/MWh:</p> <pre><code>demand_charge_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n            {\n                \"function\": \"max_many_variables\",\n                \"variables\": {\n                    \"asset_type\": \"site\",\n                    \"variable\": \"import_power_mwh\",\n                },\n                \"constant\": 40,\n                \"coefficient\": 200,\n                \"M\": max(electric_load_mwh) * 10\n            },\n        ]\n    },\n)\n</code></pre> <p>Now we see that the CHP generator has generated in the one interval that had a demand higher than our demand charge minimum of 40:</p> <pre><code>print(\n    demand_charge_simulation.results[\n        [\"site-electric_load_mwh\", \"chp-electric_generation_mwh\"]\n    ]\n)\n</code></pre> <pre><code>   site-electric_load_mwh  chp-electric_generation_mwh\n0                    30.0                          0.0\n1                    50.0                         10.0\n2                    10.0                          0.0\n</code></pre> <p>If we re-run this simulation with a lower demand charge minimum, our CHP generator is now incentivized to generate in other intervals:</p> <pre><code>demand_charge_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n            {\n                \"function\": \"max_many_variables\",\n                \"variables\": {\n                    \"asset_type\": \"site\",\n                    \"variable\": \"import_power_mwh\",\n                },\n                \"constant\": 20,\n                \"coefficient\": 200,\n                \"M\": max(electric_load_mwh) * 10,\n            },\n        ]\n    },\n)\n\nprint(\n    demand_charge_simulation.results[\n        [\"site-electric_load_mwh\", \"chp-electric_generation_mwh\"]\n    ]\n)\n</code></pre> <pre><code>   site-electric_load_mwh  chp-electric_generation_mwh\n0                    30.0                         10.0\n1                    50.0                         30.0\n2                    10.0                          0.0\n</code></pre>"},{"location":"how-to/custom-objectives/#minimum-export-incentive","title":"Minimum Export Incentive","text":"<p>Above we looked at a function term that took the maximum across many linear program variables at once using the <code>max_many_variables</code> function term, which results in one term being added to the objective function.</p> <p>Another type of function term included in <code>energypylinear</code> is the <code>min_two_variables</code> function term, which adds one term to the objective function for each interval in the linear program. </p> <p>The term will represent the minimum of either a linear program variable and another linear program variable, or a linear program variable and a user supplied constant.</p> <p>To demonstrate this we can look at a site where we want to incentivize a minimum export of 15 MWh or greater in each interval.  The site will receive the maximum benefit when exporting 15 MW or more, and less benefit when exporting less than 15 MWh. There is no incentive to export more than 15 MWh.</p> <p>Let's first setup a site with a CHP system:</p> <pre><code>import energypylinear as epl\n\nelectric_load_mwh = [30.0, 50.0, 10.0]\nelectricity_prices = [0.0, 0.0, 0.0]\ngas_prices = 20\n\nsite = epl.Site(\n    assets=[\n        epl.CHP(\n            electric_efficiency_pct=1.0,\n            electric_power_max_mw=50,\n            electric_power_min_mw=0,\n        )\n    ],\n    gas_prices=gas_prices,\n    electricity_prices=electricity_prices,\n    electric_load_mwh=electric_load_mwh,\n)\n</code></pre> <p>Let's optimize the site without a minimum export incentive:</p> <pre><code>no_export_incentive_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n        ]\n    },\n)\n\nprint(no_export_incentive_simulation.results['chp-electric_generation_mwh'])\n</code></pre> <p>As expected, our CHP system doesn't generate:</p> <pre><code>0    0.0\n1    0.0\n2    0.0\nName: chp-electric_generation_mwh, dtype: float64\n</code></pre> <p>Let's now add a minimum export incentive using the <code>min_two_variables</code> function term:</p> <pre><code>no_export_incentive_simulation = site.optimize(\n    verbose=3,\n    objective={\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"*\",\n                \"variable\": \"gas_consumption_mwh\",\n                \"interval_data\": \"gas_prices\",\n            },\n            {\n                \"function\": \"min_two_variables\",\n                \"a\": {\n                    \"asset_type\": \"site\",\n                    \"variable\": \"export_power_mwh\",\n                },\n                \"b\": 15,\n                \"coefficient\": -200,\n                \"M\": max(electric_load_mwh) * 10\n            },\n        ]\n    },\n)\n\nprint(\n    no_export_incentive_simulation.results[\n        [\n            \"site-electric_load_mwh\",\n            \"site-export_power_mwh\",\n            \"chp-electric_generation_mwh\",\n        ]\n    ]\n)\n</code></pre> <p>As expected, our CHP system generates to export a minimum of 15 MWh where possible:</p> <pre><code>   site-electric_load_mwh  site-export_power_mwh  chp-electric_generation_mwh\n0                    30.0                   15.0                         45.0\n1                    50.0                    0.0                          0.0\n2                    10.0                   15.0                         25.0\n</code></pre> <p>Our asset does not generate in the second interval because the site demand is too high to allow the asset to export any electricity.</p>"},{"location":"how-to/dispatch-forecast/","title":"Forecast","text":"<p><code>energypylinear</code> has the ability to optimize for both actuals &amp; forecasts.</p> <p>An asset (or site) can be used to model the variance between optimizing for actual &amp; forecast prices.</p>"},{"location":"how-to/dispatch-forecast/#setup-interval-data","title":"Setup Interval Data","text":"<pre><code>electricity_prices = [100, 50, 200, -100, 0, 200, 100, -100]\nforecasts = [-100, 0, 200, 100, -100, 100, 50, 200]\n</code></pre>"},{"location":"how-to/dispatch-forecast/#optimize-with-perfect-foresight","title":"Optimize with Perfect Foresight","text":"<pre><code>import energypylinear as epl\n\nasset = epl.Battery(\n    power_mw=2,\n    capacity_mwh=4,\n    efficiency_pct=0.9,\n    electricity_prices=electricity_prices\n)\nactual = asset.optimize(verbose=3)\nperfect_foresight = epl.get_accounts(actual.results, verbose=3)\nprint(f\"{perfect_foresight=}\")\n</code></pre> <pre><code>perfect_foresight=&lt;Accounts profit=1037.78 emissions=0.0622&gt;\n</code></pre>"},{"location":"how-to/dispatch-forecast/#optimize-to-a-forecast","title":"Optimize to a Forecast","text":"<pre><code>import energypylinear as epl\n\nasset = epl.Battery(\n    power_mw=2,\n    capacity_mwh=4,\n    efficiency_pct=0.9,\n    electricity_prices=forecasts\n)\nforecast = asset.optimize(verbose=3)\nforecast_account = epl.get_accounts(\n    forecast.results,\n    price_results=actual.results,\n    verbose=3\n)\nprint(f\"{forecast_account=}\")\n</code></pre> <pre><code>forecast_account=&lt;Accounts profit=-140.00 emissions=0.0800&gt;\n</code></pre>"},{"location":"how-to/dispatch-forecast/#calculate-variance-between-accounts","title":"Calculate Variance Between Accounts","text":"<pre><code>variance = perfect_foresight - forecast_account\nprint(f\"{variance=}\")\n</code></pre> <pre><code>variance=&lt;Account profit=1177.78 emissions=-0.0178&gt;\n</code></pre>"},{"location":"how-to/dispatch-forecast/#full-example","title":"Full Example","text":"<pre><code>import io\n\nimport pandas as pd\n\nimport energypylinear as epl\n\n#  price and forecast csv data\nraw = \"\"\"\nTimestamp,Trading Price [$/MWh],Predispatch Forecast [$/MWh]\n2018-07-01 17:00:00,177.11,97.58039000000001\n2018-07-01 17:30:00,135.31,133.10307\n2018-07-01 18:00:00,143.21,138.59978999999998\n2018-07-01 18:30:00,116.25,128.09559\n2018-07-01 19:00:00,99.97,113.29413000000001\n2018-07-01 19:30:00,99.71,113.95063\n2018-07-01 20:00:00,97.81,105.5491\n2018-07-01 20:30:00,96.1,102.99768\n2018-07-01 21:00:00,98.55,106.34366000000001\n2018-07-01 21:30:00,95.78,91.82700000000001\n2018-07-01 22:00:00,98.46,87.45\n2018-07-01 22:30:00,91.88,85.65775\n2018-07-01 23:00:00,91.69,85.0\n2018-07-01 23:30:00,101.2,85.0\n2018-07-02 00:00:00,139.55,80.99999\n2018-07-02 00:30:00,102.9,75.85762\n2018-07-02 01:00:00,83.86,67.86758\n2018-07-02 01:30:00,71.1,70.21946\n2018-07-02 02:00:00,60.35,62.151\n2018-07-02 02:30:00,56.01,62.271919999999994\n2018-07-02 03:00:00,51.22,56.79063000000001\n2018-07-02 03:30:00,48.55,53.8532\n2018-07-02 04:00:00,55.17,53.52591999999999\n2018-07-02 04:30:00,56.21,49.57504\n2018-07-02 05:00:00,56.32,48.42244\n2018-07-02 05:30:00,58.79,54.15495\n2018-07-02 06:00:00,73.32,58.01054\n2018-07-02 06:30:00,80.89,68.31508000000001\n2018-07-02 07:00:00,88.43,85.0\n2018-07-02 07:30:00,201.43,119.73926999999999\n2018-07-02 08:00:00,120.33,308.88984\n2018-07-02 08:30:00,113.26,162.32117\n\"\"\"\ndata = pd.read_csv(io.StringIO(raw))\n\n#  optimize for actuals\nasset = epl.Battery(\n    power_mw=2,\n    capacity_mwh=4,\n    efficiency_pct=0.9,\n    electricity_prices=data[\"Trading Price [$/MWh]\"].values,\n    freq_mins=30,\n)\nactuals = asset.optimize(verbose=3)\n\n#  optimize for forecasts\nasset = epl.Battery(\n    power_mw=2,\n    capacity_mwh=4,\n    efficiency_pct=0.9,\n    electricity_prices=data[\"Predispatch Forecast [$/MWh]\"].values,\n    freq_mins=30,\n)\nforecasts = asset.optimize(verbose=3)\n\n#  calculate the variance between accounts\nactual_account = epl.get_accounts(\n    actuals.results, verbose=3\n\n)\nforecast_account = epl.get_accounts(\n    forecasts.results,\n    price_results=actuals.results,\n    verbose=3\n)\nvariance = actual_account - forecast_account\n\nprint(f\"actuals: {actual_account}\")\nprint(f\"forecasts: {forecast_account}\")\nprint(f\"variance: {variance}\")\nprint(\n    f\"\\nforecast error: $ {-1 * variance.cost:2.2f} pct: {100 * variance.cost / actual_account.cost:2.1f} %\"\n)\n</code></pre> <pre><code>actuals: &lt;Accounts profit=325.82 emissions=0.0644&gt;\nforecasts: &lt;Accounts profit=232.85 emissions=0.0544&gt;\nvariance: &lt;Account profit=92.97 emissions=0.0100&gt;\n\nforecast error: $ 92.97 pct: 28.5 %\n</code></pre>"},{"location":"how-to/dispatch-site/","title":"Multiple Assets with the Site API","text":"<p><code>energypylinear</code> can optimize many assets in a single linear program.</p> <p>The <code>epl.Site</code> accepts a list of <code>energypylinear</code> asset models, like <code>epl.Battery</code> or <code>epl.RenewableGenerator</code>.</p> <p>Below are examples of typical configurations of multiple energy assets using a <code>epl.Site</code>.</p>"},{"location":"how-to/dispatch-site/#fast-slow-battery","title":"Fast &amp; Slow Battery","text":"<p>Optimize a fast and slow battery alongside each other:</p> <pre><code>import energypylinear as epl\n\nsite = epl.Site(\n    assets=[\n        epl.Battery(\n            power_mw=4.0,\n            capacity_mwh=1.0,\n            initial_charge_mwh=1,\n            final_charge_mwh=1\n        ),\n        epl.Battery(\n            power_mw=2.0,\n            capacity_mwh=4.0,\n            initial_charge_mwh=4.0,\n            final_charge_mwh=0.0,\n            name=\"battery-2\",\n        ),\n    ],\n    electricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\n    freq_mins=60,\n)\n\nsimulation = site.optimize()\n</code></pre>"},{"location":"how-to/dispatch-site/#battery-ev-chargers","title":"Battery &amp; EV Chargers","text":"<p>Optimize a battery next to an EV charging station:</p> <pre><code>import energypylinear as epl\n\nsite = epl.Site(\n    assets=[\n        epl.Battery(\n            power_mw=2.0,\n            capacity_mwh=4.0,\n            initial_charge_mwh=1,\n            final_charge_mwh=3,\n        ),\n        epl.EVs(\n            chargers_power_mw=[100, 100],\n            charger_turndown=0.1,\n            charge_events=[\n                [1, 0, 0, 0, 0, 0, 0, 0],\n                [0, 1, 1, 1, 0, 0, 0, 0],\n                [0, 0, 0, 1, 1, 0, 0, 0],\n                [0, 1, 0, 0, 0, 0, 0, 0],\n            ],\n            charge_events_capacity_mwh=[50, 100, 30, 40],\n        ),\n    ],\n    electricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\n    freq_mins=60,\n)\n\nsimulation = site.optimize()\n</code></pre>"},{"location":"how-to/dispatch-site/#battery-chp","title":"Battery &amp; CHP","text":"<p>Optimize an electric battery alongside a gas fired CHP:</p> <pre><code>import energypylinear as epl\n\nsite = epl.Site(\n    assets=[\n        epl.Battery(\n            power_mw=2.0,\n            capacity_mwh=4.0,\n            initial_charge_mwh=1,\n            final_charge_mwh=3\n        ),\n        epl.CHP(\n            electric_power_max_mw=100,\n            electric_power_min_mw=30,\n            electric_efficiency_pct=0.4,\n        ),\n    ],\n    electricity_prices=[100.0, 50, 200, -100, 0, 200, 100, -100],\n    freq_mins=60,\n)\n\nsimulation = site.optimize()\n</code></pre>"},{"location":"how-to/network-charges/","title":"Network Charges","text":"<p><code>energypylinear</code> has the ability to optimize for a network charge.</p> <p>A network charge is a tariff applied to a site based on the power consumed in certain intervals.  It's often set to incentive reductions in demand during peak periods.</p>"},{"location":"how-to/network-charges/#no-network-charge","title":"No Network Charge","text":""},{"location":"how-to/network-charges/#asset-interval-data-and-objective-function","title":"Asset, Interval Data and Objective Function","text":"<p>First we will setup a battery with no network charge, and optimize it for electricity prices:</p> <pre><code>import energypylinear as epl\n\nelectricity_prices = [50, 100, 150]\nasset = epl.Battery(electricity_prices=electricity_prices, efficiency=0.9)\nbau = asset.optimize(\n    {\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n        ]\n    },\n    verbose=5\n)\n</code></pre>"},{"location":"how-to/network-charges/#results","title":"Results","text":"<p>We can then calculate the net import and battery charge:</p> <pre><code>results = bau.results\nresults[\"battery-net_charge_mwh\"] = (\n    results[\"battery-electric_charge_mwh\"] - results[\"battery-electric_discharge_mwh\"]\n)\nresults[\"site-net_import_mwh\"] = (\n    results[\"site-import_power_mwh\"] - results[\"site-export_power_mwh\"]\n)\nprint(\n    bau.results[\n        [\n            \"site-electricity_prices\",\n            \"site-net_import_mwh\",\n            \"battery-net_charge_mwh\",\n            \"battery-electric_final_charge_mwh\",\n        ]\n    ]\n)\n</code></pre> <p>As expected, our battery charges during the first two intervals when electricity prices are low, and discharges during the third interval when prices are high:</p> <pre><code>   site-electricity_prices  site-net_import_mwh  battery-net_charge_mwh  battery-electric_final_charge_mwh\n0                     50.0             2.000000                2.000000                                1.8\n1                    100.0             0.222222                0.222222                                2.0\n2                    150.0            -2.000000               -2.000000                                0.0\n</code></pre>"},{"location":"how-to/network-charges/#with-network-charge","title":"With Network Charge","text":""},{"location":"how-to/network-charges/#asset-and-interval-data","title":"Asset and Interval Data","text":"<p>By default, <code>energypylinear</code> uses interval data like <code>electricity_prices</code> or <code>electricity_carbon_intensities</code>.  This interval data is supplied when initializing an asset or site.</p> <p>For network charges, we will make use of the ability to supply custom interval data. Any extra keyword arguments supplied to an asset or site will be attempted to be parsed as interval data.</p> <p>Below we setup a battery with both electricity prices and a network charge:</p> <pre><code>import energypylinear as epl\n\nassert electricity_prices == [50, 100, 150]\nnetwork_charge = [0, 100, 0]\nasset = epl.Battery(electricity_prices=electricity_prices, network_charge=network_charge)\n</code></pre>"},{"location":"how-to/network-charges/#objective-function","title":"Objective Function","text":"<p>By default, <code>energypylinear</code> has two built-in objective functions - <code>price</code> and <code>carbon</code>.</p> <p>In order to optimize for a network charge, we need to supply a custom objective function.  This function will be passed to the <code>optimize</code> method of an asset or site.</p> <p>Below we optimize our battery with a custom objective function:</p> <pre><code>network_charge = asset.optimize(\n    {\n        \"terms\": [\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"export_power_mwh\",\n                \"interval_data\": \"electricity_prices\",\n                \"coefficient\": -1,\n            },\n            {\n                \"asset_type\": \"site\",\n                \"variable\": \"import_power_mwh\",\n                \"interval_data\": \"network_charge\",\n                \"coefficient\": 1,\n            },\n        ]\n    },\n    verbose=3\n)\n</code></pre>"},{"location":"how-to/network-charges/#results_1","title":"Results","text":"<pre><code>results = network_charge.results\nresults[\"battery-net_charge_mwh\"] = (\n    results[\"battery-electric_charge_mwh\"] - results[\"battery-electric_discharge_mwh\"]\n)\nresults[\"site-net_import_mwh\"] = (\n    results[\"site-import_power_mwh\"] - results[\"site-export_power_mwh\"]\n)\nprint(\n    network_charge.results[\n        [\n            \"site-electricity_prices\",\n            \"site-network_charge\",\n            \"site-net_import_mwh\",\n            \"battery-net_charge_mwh\",\n            \"battery-electric_final_charge_mwh\",\n        ]\n    ]\n)\n</code></pre> <p>We now see that our battery has not charged during the second interval, where we have a high site network charge:</p> <pre><code>   site-electricity_prices  site-network_charge  site-net_import_mwh  battery-net_charge_mwh  battery-electric_final_charge_mwh\n0                     50.0                  0.0                  2.0                     2.0                                1.8\n1                    100.0                100.0                  0.0                     0.0                                1.8\n2                    150.0                  0.0                 -1.8                    -1.8                                0.0\n</code></pre>"},{"location":"how-to/price-carbon/","title":"Carbon","text":"<p><code>energypylinear</code> can optimize for both price and carbon as optimization objectives.</p> <p>This ability comes from two things - an objective function, which can be either for price or carbon, along with accounting of both price and carbon emissions.</p> <p>We can dispatch a battery to minimize carbon emissions by passing in <code>objective='carbon'</code>:</p>"},{"location":"how-to/price-carbon/#setup-interval-data","title":"Setup Interval Data","text":"<pre><code>import energypylinear as epl\n\nelectricity_prices = [100, 50, 200, -100, 0, 200, 100, -100]\nelectricity_carbon_intensities = [0.1, 0.2, 0.1, 0.15, 0.01, 0.7, 0.5, 0.01]\n</code></pre>"},{"location":"how-to/price-carbon/#optimize-for-carbon","title":"Optimize for Carbon","text":"<pre><code>asset = epl.Battery(\n    power_mw=2,\n    capacity_mwh=4,\n    efficiency_pct=0.9,\n    electricity_prices=electricity_prices,\n    electricity_carbon_intensities=electricity_carbon_intensities,\n)\ncarbon = asset.optimize(objective=\"carbon\", verbose=3)\n\ncarbon_account = epl.get_accounts(carbon.results, verbose=3)\nprint(f\"{carbon_account=}\")\n</code></pre> <pre><code>carbon_account=&lt;Accounts profit=134.44 emissions=-2.2733&gt;\n</code></pre>"},{"location":"how-to/price-carbon/#optimize-for-money","title":"Optimize for Money","text":"<p>We can compare these results above with a simulation that optimizes for price, using a <code>energypylinear.accounting.Account</code> to compare both simulations.</p> <p>Our optimization for price has a high negative cost.</p> <p>The optimization for carbon has lower emissions, but at a higher cost:</p> <pre><code>asset = epl.Battery(\n    power_mw=2,\n    capacity_mwh=4,\n    efficiency_pct=0.9,\n    electricity_prices=electricity_prices,\n    electricity_carbon_intensities=electricity_carbon_intensities,\n)\nprice = asset.optimize(\n    objective=\"price\",\n    verbose=3\n)\n\nprice_account = epl.get_accounts(price.results, verbose=3)\nprint(f\"{price_account=}\")\n</code></pre> <pre><code>price_account=&lt;Accounts profit=1037.78 emissions=-1.6578&gt;\n</code></pre>"},{"location":"how-to/price-carbon/#calculate-variance-between-accounts","title":"Calculate Variance Between Accounts","text":"<pre><code>variance = price_account - carbon_account\nprint(f\"{variance=}\")\nprint(f\"{-variance.cost / variance.emissions:.2f} $/tC\")\n</code></pre> <pre><code>variance=&lt;Account profit=903.33 emissions=0.6156&gt;\n1467.51 $/tC\n</code></pre>"},{"location":"how-to/price-carbon/#full-example","title":"Full Example","text":"<pre><code>import energypylinear as epl\n\nelectricity_prices = [100, 50, 200, -100, 0, 200, 100, -100]\nelectricity_carbon_intensities = [0.1, 0.2, 0.1, 0.15, 0.01, 0.7, 0.5, 0.01]\nasset = epl.Battery(\n    power_mw=2,\n    capacity_mwh=4,\n    efficiency_pct=0.9,\n    electricity_prices=electricity_prices,\n    electricity_carbon_intensities=electricity_carbon_intensities,\n)\n\n# optimize for carbon\ncarbon = asset.optimize(objective=\"carbon\", verbose=3)\ncarbon_account = epl.get_accounts(carbon.results, verbose=3)\nprint(f\"{carbon_account=}\")\n\n# optimize for money\nprice = asset.optimize(\n    objective=\"price\",\n    verbose=3\n)\nprice_account = epl.get_accounts(price.results, verbose=3)\nprint(f\"{price_account=}\")\n\n# calculate variance (difference) between accounts\nvariance = price_account - carbon_account\nprint(f\"{variance=}\")\nprint(f\"{-variance.cost / variance.emissions:.2f} $/tC\")\n</code></pre>"},{"location":"how-to/renewables-and-battery/","title":"Renewable Generator, Battery and Site Limits","text":"<p><code>energypylinear</code> has the ability to optimize a battery located with renewable electricity generation.</p> <p>This example shows how to model a site with a renewable generator and battery that can export electricity to the grid.</p> <p>First, let's set up a site with two assets - a solar generator and battery, with a site export limit of 25 MW:</p> <pre><code>import energypylinear as epl\n\n# Create assets:\n# - 10 MW / 20 MWh battery with 90% round-trip efficiency\n# - Solar generator with a predefined generation profile (10-30 MW across 5 intervals)\n# - Generator can be curtailed down to 50% of available generation\n# - Custom name \"solar\" for the generator\nassets = [\n    epl.Battery(power_mw=10, capacity_mwh=20, efficiency_pct=0.9),\n    epl.RenewableGenerator(\n        electric_generation_mwh=[10, 20, 30, 20, 10],\n        electric_generation_lower_bound_pct=0.5,\n        name=\"solar\",\n    ),\n]\n\n# Configure site:\n# - Carbon intensity values for each interval (negative values represent low carbon periods)\n# - Maximum export limit of 25 MW to the grid\nsite = epl.Site(\n    assets=assets,\n    electricity_carbon_intensities=[0.5, -0.5, 0.5, 0.5, -0.5],\n    export_limit_mw=25,\n)\n\n# Optimize for carbon minimization rather than profit maximization\nsimulation = site.optimize(objective=\"carbon\")\n</code></pre>"}]}